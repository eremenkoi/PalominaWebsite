<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sunday Gravy Client Portal Dashboard</title>
  <style>
    /* Global Styles */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9f9f9;
    }
    header.global-header {
      text-align: center;
      margin-bottom: 10px;
      font-size: 24px;
      font-weight: bold;
    }
    header.main-header {
      text-align: center;
      margin-bottom: 20px;
    }
    /* Tabs */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin: 0 5px;
    }
    .tab.active {
      border-color: #333;
      font-weight: bold;
    }
    .view {
      display: none;
    }
    .view.active {
      display: block;
    }
    /* Table Container (Calendar View) */
    .table-container {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 33vh;
      width: 100%;
      border: 1px solid #ccc;
      margin-top: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 800px;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 8px;
      text-align: left;
      white-space: nowrap;
    }
    th {
      position: relative;
      cursor: pointer;
      background-color: #f2f2f2;
    }
    /* Custom sort indicator styles */
    th.sort-asc::after {
      content: " ▲";
      position: absolute;
      right: 8px;
    }
    th.sort-desc::after {
      content: " ▼";
      position: absolute;
      right: 8px;
    }
    th[data-sort] {
      cursor: pointer;
      position: relative;
    }
    th[data-sort]:hover {
      background-color: #e9e9e9;
    }
    /* Expiring date colors for table */
    tr.expires-soon td {
      background-color: #ffebee;
      color: #c62828;
    }
    tr.expired td {
      background-color: #f5f5f5;
      color: #616161;
    }
    tr.active td {
      background-color: #e3f2fd;
      color: #0d47a1;
    }
    tr.upcoming td {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    /* Gallery Card Styles */
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .product-card, .job-card {
      background: #fff;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .product-card:hover, .job-card:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    .card-title {
      font-weight: bold;
      font-size: 16px;
      margin: 8px 0 4px;
    }
    .card-info {
      font-size: 12px;
      color: #666;
      margin: 2px 0;
    }
    .gallery-search {
      display: flex;
      margin-bottom: 15px;
      gap: 10px;
      flex-wrap: wrap;
    }
    .gallery-search input, .gallery-search select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .gallery-search input {
      flex: 1;
      min-width: 200px;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .btn:hover {
      background: #0069d9;
    }
    .btn-alt {
      background: #6c757d;
    }
    .btn-alt:hover {
      background: #5a6268;
    }
    /* Table filter controls */
    .table-controls {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      flex-wrap: wrap;
      gap: 10px;
    }
    .table-filters {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    .table-filters label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Enhanced Timeline Styles */
    .timeline-container {
      margin-bottom: 20px;
      border: 1px solid #ccc;
      padding: 10px;
      background: #fff;
      position: relative;
      overflow-x: auto;
      min-height: 300px;
    }
    .timeline-ruler {
      position: relative;
      height: 30px;
      border-bottom: 1px solid #ccc;
      z-index: 1;
    }
    .timeline-month {
      position: absolute;
      border-left: 1px solid #aaa;
      height: 15px;
      top: 15px;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
    }
    .timeline-month span {
      position: relative;
      top: -15px;
      left: 3px;
      white-space: nowrap;
      color: #333;
    }
    .timeline-events {
      position: relative;
      min-height: 200px;
      z-index: 2;
      padding-top: 10px;
    }
    /* Today marker */
    .timeline-today {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background-color: #ff4d4d;
      z-index: 5;
      box-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
    }
    .timeline-today::after {
      content: "Today";
      position: absolute;
      top: -25px;
      left: -20px;
      background: #ff4d4d;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    /* Timeline event styling */
    .timeline-event {
      position: absolute;
      background: #e8f5e9;
      border: 1px solid #4caf50;
      border-radius: 4px;
      padding: 6px 8px;
      min-width: 100px;
      font-size: 12px;
      cursor: pointer;
      overflow: visible;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      z-index: 3;
    }
    .timeline-event:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }
    .timeline-event .event-title {
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 11px;
    }
    .timeline-event .event-dates {
      font-size: 9px;
      opacity: 0.9;
      margin-top: 2px;
    }
    .timeline-event-active {
      background: #e3f2fd;
      border-color: #2196f3;
      color: #0d47a1;
    }
    .timeline-event-expiring {
      background: #fff8e1;
      border-color: #ffc107;
      color: #ff6f00;
    }
    .timeline-event-expired {
      background: #f5f5f5;
      border-color: #9e9e9e;
      color: #616161;
      opacity: 0.85;
    }
    /* Timeline legend */
    .timeline-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 15px 0;
      border-top: 1px solid #eee;
      padding-top: 10px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      display: inline-block;
    }
    .color-active {
      background: #e3f2fd;
      border: 1px solid #2196f3;
    }
    .color-expiring {
      background: #fff8e1;
      border: 1px solid #ffc107;
    }
    .color-expired {
      background: #f5f5f5;
      border: 1px solid #9e9e9e;
    }
    /* Jobs Gallery styles */
    .jobs-table-wrapper {
      width: 100%;
      margin-top: 15px;
    }
    .count-display {
      margin-bottom: 15px;
    }
    /* Job detail modal */
    .job-detail-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
    }
    .job-detail-content {
      background-color: white;
      margin: 5% auto;
      padding: 20px;
      width: 90%;
      max-width: 1200px;
      max-height: 80%;
      overflow-y: auto;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .job-detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .job-detail-close {
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
    }
    .job-detail-table {
      width: 100%;
      margin-top: 15px;
    }
    /* Debug section */
    #debugOutput {
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    /* For job detail tables */
    .job-detail-table th {
      width: 200px;
      vertical-align: top;
      background-color: #f5f5f5;
    }
    .job-detail-table td {
      vertical-align: top;
    }
  </style>
</head>
<body>
  <!-- Global Header: Sunday Gravy instead of DDB Melbourne -->
  <header class="global-header">
    Sunday Gravy
  </header>
  <!-- Main Header -->
  <header class="main-header">
    <h1>Sunday Gravy Client Portal</h1>
    <p>Dashboard – Select a view below</p>
    <div class="current-date" id="currentDate"></div>
  </header>
  <!-- Tab Navigation - Changed Campaign Gallery to Product Gallery -->
  <div class="tabs">
    <div class="tab active" data-target="calendarView">Calendar View</div>
    <div class="tab" data-target="productGallery">Product Gallery</div>
    <div class="tab" data-target="jobsGallery">Jobs Gallery</div>
  </div>

  <!-- Calendar View -->
  <div id="calendarView" class="view active">
    <h2>Contract Expiration Calendar</h2>
    <!-- Debug Section -->
    <div id="debugOutput" class="field-debug"></div>
    <button onclick="toggleDebug()" style="margin-bottom: 10px;">Toggle Debug Info</button>
    <!-- Timeline Controls (Zoom Only) -->
    <div class="timeline-controls">
      <div>
        <button id="zoomOut">-</button>
        <button id="zoomReset">Reset Zoom</button>
        <button id="zoomIn">+</button>
        <button id="centerToday">Center on Today</button>
      </div>
    </div>
    <!-- Timeline Component -->
    <div id="timeline-container" class="timeline-container">
      <div id="timeline-ruler" class="timeline-ruler"></div>
      <div id="timeline-events" class="timeline-events"></div>
    </div>
    <h2>Contracts</h2>
    <div class="gallery-search">
      <input type="text" id="tableJobNumberFilter" placeholder="Filter by Job Number" />
      <input type="text" id="tableJobNameFilter" placeholder="Filter by Job Name" />
      <select id="advertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <button class="btn" onclick="applyTableFilters()">Search</button>
      <button class="btn btn-alt" onclick="downloadTableCSV()">Download CSV</button>
    </div>
    <!-- Table Controls -->
    <div class="table-controls">
      <div class="table-filters">
        <label><input type="checkbox" id="tableShowExpired" checked> Show Expired</label>
        <label><input type="checkbox" id="tableShowActive" checked> Show Active</label>
        <label><input type="checkbox" id="tableShowUpcoming" checked> Show Upcoming</label>
        <button class="btn" onclick="applyTableFilters()">Apply Filters</button>
      </div>
    </div>
    <div id="calendarTableContainer" class="table-container">
      Loading contracts...
    </div>
  </div>

  <!-- Product Gallery View (renamed from Campaign Gallery) -->
  <div id="productGallery" class="view">
    <h2>Product Gallery</h2>
    <div class="gallery-search">
      <input type="text" id="productFilter" placeholder="Filter by Product Name" />
      <select id="productAdvertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <!-- Re-render products with current filters -->
      <button class="btn" onclick="renderProductsFromRecords()">Search</button>
    </div>
    <div id="productGalleryContent" class="gallery-grid">
      Loading products...
    </div>
    <!-- Product Jobs Table (hidden by default) -->
    <div id="productJobsContainer" style="display: none; margin-top: 20px;">
      <div class="table-header">
        <h3 id="selectedProductTitle">Product Jobs</h3>
        <button class="btn btn-alt" onclick="backToProducts()">Back to Products</button>
        <button class="btn btn-alt" onclick="downloadProductJobsCSV()">Download CSV</button>
        <button class="btn btn-alt" onclick="printProductJobsCSV()">Print CSV</button>
      </div>

      <div id="productJobsTableContainer" class="table-container">
        Loading jobs...
      </div>
    </div>
  </div>

  <!-- Jobs Gallery View -->
  <div id="jobsGallery" class="view">
    <h2>Jobs Gallery</h2>
    <div class="gallery-search">
      <input type="text" id="jobsGalleryNumberFilter" placeholder="Filter by Job Number" />
      <input type="text" id="jobsGalleryNameFilter" placeholder="Filter by Job Name" />
      <select id="jobsGalleryAdvertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <button class="btn" onclick="loadJobsGallery()">Search</button>
      <button class="btn btn-alt" onclick="downloadJobsCSV()">Download CSV</button>
    </div>
    <div id="jobsGalleryContent">
      <div class="count-display"></div>
      <div class="jobs-table-wrapper table-container">
        Loading jobs...
      </div>
    </div>
  </div>

  <!-- Job Detail Modal -->
  <div id="jobDetailModal" class="job-detail-modal">
    <div class="job-detail-content">
      <div class="job-detail-header">
        <h2 id="jobDetailTitle">Job Details</h2>
        <span class="job-detail-close" onclick="closeJobDetail()">&times;</span>
      </div>
      <div id="jobDetailContent"></div>
    </div>
  </div>

  <script>
    // Global variables
    const TODAY = new Date();
    TODAY.setHours(0, 0, 0, 0);
    let pxPerDay = 20; // Default zoom level for timeline
    let currentRecords = []; // Store all records
    let currentProducts = []; // Store all products
    let currentAdvertisers = []; // Store all advertisers for filters
    let currentSortField = 'firstOnAir'; // Default sort field
    let currentSortDirection = 'asc'; // Default sort direction
    let selectedProduct = null; // Currently selected product
    let rawAirtableRecords = []; // Store the raw records from Airtable
    let personMap = {}; // Map of person record IDs to names
    let agencyMap = {}; // Map of agency record IDs to names

    // Debug helper function
    function debug(message) {
      const debugEl = document.getElementById('debugOutput');
      if (debugEl) {
        debugEl.innerHTML += `<div>${message}</div>`;
        console.log(message);
      }
    }

    // Extract name from a referenced record
    function extractNameFromRecord(record) {
      if (!record) return "";

      // If it's a string, just return it
      if (typeof record === 'string') return record;

      // If it's an object with fields and has a Legal Name
      if (record.fields && record.fields["Legal Name"]) {
        return record.fields["Legal Name"];
      }

      // If it's an object with a Name field
      if (record.fields && record.fields["Name"]) {
        return record.fields["Name"];
      }

      // If it's an object with a name property
      if (record.name) {
        return record.name;
      }

      // Return the ID if all else fails
      return record.id || "";
    }

    // Utility: Format date in a friendly format (e.g., 3 October 2023)
    function formatFriendlyDate(date) {
      if (!date || isNaN(date.getTime())) return "";
      return date.toLocaleDateString('en-AU', {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      });
    }

    // Utility: Format date in standard format (DD/MM/YYYY)
    function formatStandardDate(date) {
      if (!date || isNaN(date.getTime())) return "";
      return date.toLocaleDateString('en-AU', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
      });
    }

    // Format term in user-friendly format (weeks, months, years)
    function formatUserFriendlyTerm(startDate, endDate) {
      if (!startDate || !endDate) return "N/A";
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) return "N/A";
      const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
      if (daysDiff >= 365) {
        const years = Math.ceil(daysDiff / 365);
        return years + (years === 1 ? ' year' : ' years');
      }
      if (daysDiff >= 30) {
        const months = Math.ceil(daysDiff / 30);
        return months + (months === 1 ? ' month' : ' months');
      }
      if (daysDiff >= 7) {
        const weeks = Math.ceil(daysDiff / 7);
        return weeks + (weeks === 1 ? ' week' : ' weeks');
      }
      return daysDiff + (daysDiff === 1 ? ' day' : ' days');
    }

    // Improved date parser that handles multiple formats
    function parseDate(dateStr) {
      if (!dateStr) return null;
      const cleanStr = dateStr.trim();
      // ISO format: YYYY-MM-DD
      const isoMatch = cleanStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (isoMatch) {
        const [_, year, month, day] = isoMatch;
        return new Date(Number(year), Number(month) - 1, Number(day));
      }
      // DD/MM/YYYY format
      const dmyMatch = cleanStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
      if (dmyMatch) {
        const [_, day, month, year] = dmyMatch;
        return new Date(Number(year), Number(month) - 1, Number(day));
      }
      // "Month Day, Year" format (e.g., "January 15, 2023")
      const monthNameMatch = cleanStr.match(/^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})$/);
      if (monthNameMatch) {
        const [_, monthName, day, year] = monthNameMatch;
        const monthIndex = new Date(`${monthName} 1, 2000`).getMonth();
        if (!isNaN(monthIndex)) {
          return new Date(Number(year), monthIndex, Number(day));
        }
      }
      // Fallback: Use built-in Date parsing
      const parsed = new Date(cleanStr);
      if (!isNaN(parsed.getTime())) {
        return parsed;
      }
      console.warn("Failed to parse date:", dateStr);
      return null;
    }

    // Process Airtable records, filtering for 'EG' job numbers
    function processRecords(records) {
      if (!records || !Array.isArray(records)) return [];
      debug(`Processing ${records.length} records from Airtable...`);

      // First filter for job numbers starting with 'EG'
      records = records.filter(record => {
        const jobNumber = record.fields && (record.fields["Job Number"] || record.fields["Job No."]) || "";
        return jobNumber.startsWith('EG');
      });

      debug(`Found ${records.length} records with job numbers starting with 'EG'`);

      const processedRecords = [];
      personMap = {}; // Clear existing maps
      agencyMap = {};
      productMap = {};  // Map for products
      jobTrackerMap = {}; // Map for job trackers
      const jobMap = {}; // Map to collect jobs by ID

      // First pass: build lookup maps for all linked records
      records.forEach(record => {
        const fields = record.fields || {};

        // Store this record in jobMap for lookup
        if (record.id) {
          jobMap[record.id] = record;
        }

        // Process Person records (performers)
        if (fields["Person"] && Array.isArray(fields["Person"])) {
          fields["Person"].forEach(person => {
            if (typeof person === 'object' && person.id) {
              if (person.fields && person.fields["Legal Name"]) {
                personMap[person.id] = person.fields["Legal Name"];
              }
            }
          });
        }

        // Process Agency records
        if (fields["Talent Agency"] && Array.isArray(fields["Talent Agency"])) {
          fields["Talent Agency"].forEach(agency => {
            if (typeof agency === 'object' && agency.id) {
              if (agency.fields && agency.fields["Name"]) {
                agencyMap[agency.id] = agency.fields["Name"];
              }
            }
          });
        }

        // Track products for product gallery
        if (fields["Product"]) {
          const product = fields["Product"];
          if (!productMap[product]) {
            productMap[product] = {
              name: product,
              jobs: []
            };
          }
          productMap[product].jobs.push(record.id);
        }

        // Track Job Trackers if present
        if (fields["Job Trackers"] && Array.isArray(fields["Job Trackers"])) {
          fields["Job Trackers"].forEach(tracker => {
            if (typeof tracker === 'object' && tracker.id) {
              jobTrackerMap[tracker.id] = tracker;
            } else if (typeof tracker === 'string') {
              jobTrackerMap[tracker] = { id: tracker };
            }
          });
        }
      });

      debug(`Built lookup maps: ${Object.keys(personMap).length} persons, ${Object.keys(agencyMap).length} agencies, ${Object.keys(productMap).length} products`);

      // Second pass: process each record with proper lookups
      records.forEach((record, index) => {
        try {
          const fields = record.fields || {};

          // Get job number and name
          const jobNumber = fields["Job Number"] || fields["Job No."] || "";
          const jobName = fields["Job Name"] || fields["Name of Spot"] || "";

          // Process dates
          const firstOnAir = parseDate(fields["First On Air"]) || new Date();
          const contractEnd = parseDate(fields["Contract Ends"]) ||
                              parseDate(fields["Contract Ends (Calculated) Date For Sorting"]) ||
                              new Date(firstOnAir.getTime() + 30 * 86400000);

          // Get product/client from either direct field or Campaign field
          let product = "";
          if (fields["Product"]) {
            product = fields["Product"];
          } else if (fields["Job Description - Product Details"]) {
            product = fields["Job Description - Product Details"];
          } else if (fields["Advertiser"]) {
            product = fields["Advertiser"];
          } else if (fields["Advertiser WEBSITE USE"]) {
            product = fields["Advertiser WEBSITE USE"];
          }

          // Process all persons/performers instead of just one
          let performers = [];

          if (fields["Person"] && Array.isArray(fields["Person"]) && fields["Person"].length > 0) {
            // Process all persons in the array
            fields["Person"].forEach(person => {
              let personInfo = {
                id: '',
                name: ''
              };

              if (typeof person === 'string') {
                personInfo.id = person;
                personInfo.name = personMap[person] || person;
              } else if (person && typeof person === 'object') {
                if (person.id) {
                  personInfo.id = person.id;
                  if (person.fields && person.fields["Legal Name"]) {
                    personInfo.name = person.fields["Legal Name"];
                  } else {
                    personInfo.name = personMap[person.id] || person.id;
                  }
                }
              }

              if (personInfo.id) {
                performers.push(personInfo);
              }
            });
          }

          // For backward compatibility, keep performerName and performerId as the first person
          let performerName = performers.length > 0 ? performers[0].name : "";
          let performerId = performers.length > 0 ? performers[0].id : "";

          // Improved agency extraction
          let agencyName = "";
          let agencyId = "";

          if (fields["Talent Agency"] && Array.isArray(fields["Talent Agency"]) && fields["Talent Agency"].length > 0) {
            const agency = fields["Talent Agency"][0];

            if (typeof agency === 'string') {
              // If it's a string, it's just an ID
              agencyId = agency;
              agencyName = agencyMap[agency] || agency;
            } else if (agency && typeof agency === 'object') {
              // If it's an object with id property
              if (agency.id) {
                agencyId = agency.id;
                if (agency.fields && agency.fields["Name"]) {
                  agencyName = agency.fields["Name"];
                } else {
                  agencyName = agencyMap[agency.id] || agency.id;
                }
              }
            }
          }

          // Get linked Job Tracker records
          const linkedJobTrackers = [];

          // If this record has Job Trackers field, process them
          if (fields["Job Trackers"] && Array.isArray(fields["Job Trackers"])) {
            fields["Job Trackers"].forEach(tracker => {
              let trackerId = '';

              if (typeof tracker === 'string') {
                trackerId = tracker;
              } else if (tracker && tracker.id) {
                trackerId = tracker.id;
              }

              if (trackerId && jobMap[trackerId]) {
                linkedJobTrackers.push(jobMap[trackerId]);
              }
            });
          }

          // Create processed record with all the enhanced data
          processedRecords.push({
            id: record.id,
            jobNumber: jobNumber,
            jobName: jobName,
            product: product,
            nameOfSpot: jobName,
            contractTerm: fields["Contract Term"] || "",
            firstOnAir: firstOnAir,
            contractEnd: contractEnd,
            campaignRelease: fields["Campaign Release/Usage"] || "",
            campaignMedia: fields["Campaign Media/Deliverables"] || "",
            territory: fields["Territory"] || fields["Shoot Location"] || "",
            type: fields["Type"] || "",
            headShot: fields["Head Shot"] || "",
            role: fields["Role"] || "",
            contractDOR: fields["Contract / DOR"] || "",
            jobSummary: fields["Job Summary"] || fields["Job Description - Product Details"] || "",
            contractFee: fields["Contract Fee"] || "",
            loading: fields["Loading"] || "",
            options: fields["Options"] || "",
            rollover: fields["Rollover (inc VO)"] || "",
            voiceover: fields["Voiceover"] || "",
            notes: fields["NOTES Job Tracker"] || "",
            performerName: performerName,
            performerId: performerId,
            performers: performers, // Add all performers
            talentAgencyName: agencyName,
            agencyId: agencyId,
            linkedJobTrackers: linkedJobTrackers,
            rawFields: fields // Keep raw fields for reference
          });
        } catch (error) {
          debug(`Error processing record ${index}: ${error.message}`);
          console.error(`Error processing record ${index}:`, error, record);
        }
      });

      debug(`Successfully processed ${processedRecords.length} out of ${records.length} records`);

      // Log information about processed products
      const uniqueProducts = new Set();
      processedRecords.forEach(record => {
        if (record.product) {
          uniqueProducts.add(record.product);
        }
      });
      debug(`Found ${uniqueProducts.size} unique products in processed records`);

      return processedRecords;
    }

    // Extract unique advertisers/products
    function extractAdvertisers() {
      const uniqueProducts = new Set();

      currentRecords.forEach(record => {
        if (record.product) {
          uniqueProducts.add(record.product);
        }
      });

      return Array.from(uniqueProducts).sort();
    }

    // Populate advertiser dropdowns
    function updateAdvertiserDropdowns(advertisers) {
      const dropdownIds = ['advertiserFilter', 'productAdvertiserFilter', 'jobsGalleryAdvertiserFilter'];
      dropdownIds.forEach(dropdownId => {
        const dropdown = document.getElementById(dropdownId);
        if (dropdown) {
          dropdown.innerHTML = '<option value="">All Advertisers</option>';
          advertisers.forEach(advertiser => {
            const option = document.createElement('option');
            option.value = advertiser;
            option.textContent = advertiser;
            dropdown.appendChild(option);
          });
        }
      });
    }

    // Updated showJobDetails function that redirects to your existing job-details.html page
    function showJobDetails(jobId) {
      // Find the job record by its ID
      const job = currentRecords.find(r => r.id === jobId);
      if (!job) {
        alert("Job details not found");
        return;
      }

      // Store basic job info in sessionStorage for the details page
      const jobData = {
        id: job.id,
        jobNumber: job.jobNumber,
        jobName: job.jobName,
        product: job.product,
        firstOnAir: formatFriendlyDate(job.firstOnAir),
        contractEnd: formatFriendlyDate(job.contractEnd),
        contractTerm: job.contractTerm,
        campaignName: job.campaignName
      };

      // Store the data in sessionStorage so your job-details.html can use it
      sessionStorage.setItem('currentJobData', JSON.stringify(jobData));

      // Redirect directly to your existing job-details.html page
      window.location.href = `job-details.html?jobNumber=${encodeURIComponent(job.jobNumber)}`;
    }

    // Close job detail modal
    function closeJobDetail() {
      document.getElementById('jobDetailModal').style.display = 'none';
    }

    // Download table as CSV
    function downloadTableCSV(tableId, filename) {
      try {
        const table = document.querySelector("#" + tableId + " table");
        if (!table) {
          console.error("Table #" + tableId + " not found");
          return;
        }
        const headers = [];
        const headerCells = table.querySelectorAll('thead th');
        headerCells.forEach(cell => headers.push(cell.textContent.trim()));
        const rows = [];
        const rowCells = table.querySelectorAll('tbody tr');
        rowCells.forEach(row => {
          const rowData = [];
          row.querySelectorAll('td').forEach(cell => {
            const cellContent = cell.textContent.trim();
            rowData.push('"' + cellContent.replace(/"/g, '""') + '"');
          });
          rows.push(rowData.join(','));
        });
        const csvContent = [
          headers.join(','),
          ...rows
        ].join('\n');
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      } catch (err) {
        console.error("Error downloading CSV:", err);
        alert("Could not download CSV. Please try again later.");
      }
    }

    // CSV download wrappers
    function downloadTableCSV() {
      downloadTableCSV('calendarTableContainer', 'contracts.csv');
    }
    function downloadProductJobsCSV() {
      downloadTableCSV('productJobsTableContainer', 'product_' + selectedProduct + '_jobs.csv');
    }
    function downloadJobsCSV() {
      downloadTableCSV('jobsGalleryContent', 'jobs.csv');
    }

    // Print CSV function
    function printProductJobsCSV() {
      const table = document.querySelector("#productJobsTableContainer table");
      if (!table) {
        alert("No table found to print CSV");
        return;
      }
      const headers = [];
      table.querySelectorAll('thead th').forEach(cell => headers.push(cell.textContent.trim()));
      const rows = [];
      table.querySelectorAll('tbody tr').forEach(row => {
        const rowData = [];
        row.querySelectorAll('td').forEach(cell => {
          const cellContent = cell.textContent.trim();
          rowData.push('"' + cellContent.replace(/"/g, '""') + '"');
        });
        rows.push(rowData.join(','));
      });
      const csvContent = [headers.join(','), ...rows].join('\n');
      const printWindow = window.open("", "_blank");
      printWindow.document.write("<pre>" + csvContent + "</pre>");
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
    }

    // Define sortRecords function for table sorting
    function sortRecords(records, field, direction) {
      return records.sort((a, b) => {
        let valA = a[field];
        let valB = b[field];
        if (valA instanceof Date && valB instanceof Date) {
          return direction === 'asc' ? valA - valB : valB - valA;
        }
        valA = String(valA || '').toLowerCase();
        valB = String(valB || '').toLowerCase();
        if (valA < valB) return direction === 'asc' ? -1 : 1;
        if (valA > valB) return direction === 'asc' ? 1 : -1;
        return 0;
      });
    }

    // Filter records based on table filter controls
    function filterRecords(records, filterSet = 'table') {
      if (!records || !Array.isArray(records)) return [];

      try {
        // First filter to only include jobs with 'EG' prefix
        records = records.filter(record => {
          return String(record.jobNumber || '').startsWith('EG');
        });

        debug(`After 'EG' prefix filter: ${records.length} records`);

        const jobNumberElement = document.getElementById(
          filterSet === 'table' ? 'tableJobNumberFilter' :
          filterSet === 'product' ? 'productFilter' :
          'jobsGalleryNumberFilter'
        );
        const jobNameElement = document.getElementById(
          filterSet === 'table' ? 'tableJobNameFilter' :
          filterSet === 'product' ? null :
          'jobsGalleryNameFilter'
        );
        const advertiserElement = document.getElementById(
          filterSet === 'table' ? 'advertiserFilter' :
          filterSet === 'product' ? 'productAdvertiserFilter' :
          'jobsGalleryAdvertiserFilter'
        );

        const jobNumberValue = jobNumberElement ? jobNumberElement.value.trim().toLowerCase() : '';
        const jobNameValue = jobNameElement ? jobNameElement.value.trim().toLowerCase() : '';
        const advertiserValue = advertiserElement ? advertiserElement.value.trim() : '';

        // Apply user filters
        let filteredRecords = records.filter(record => {
          // Filter by job number if provided
          if (jobNumberValue && !String(record.jobNumber || '').toLowerCase().includes(jobNumberValue)) {
            return false;
          }

          // Filter by job name if provided
          if (jobNameValue && !String(record.jobName || '').toLowerCase().includes(jobNameValue)) {
            return false;
          }

          // Filter by advertiser/product if provided
          if (advertiserValue && String(record.product || '').toLowerCase() !== advertiserValue.toLowerCase()) {
            return false;
          }

          // For table view, apply status filters from checkboxes
          if (filterSet === 'table') {
            const showExpiredElement = document.getElementById('tableShowExpired');
            const showActiveElement = document.getElementById('tableShowActive');
            const showUpcomingElement = document.getElementById('tableShowUpcoming');

            if (showExpiredElement && showActiveElement && showUpcomingElement) {
              const isActive = record.firstOnAir <= TODAY && record.contractEnd >= TODAY;
              const isExpired = record.contractEnd < TODAY;
              const isUpcoming = record.firstOnAir > TODAY;

              return (isActive && showActiveElement.checked) ||
                    (isExpired && showExpiredElement.checked) ||
                    (isUpcoming && showUpcomingElement.checked);
            }
          }

          return true;
        });

        debug(`After filtering: ${filteredRecords.length} records`);
        return filteredRecords;
      } catch (error) {
        debug(`Error in filterRecords: ${error.message}`);
        return records; // Return all records on error
      }
    }

    // Apply filters: update both the table and timeline
    function applyTableFilters() {
      const filteredRecords = filterRecords(currentRecords);
      renderJobsTable(filteredRecords);
      renderTimeline(filteredRecords);
    }

    // Render contracts table
    function renderJobsTable(records) {
      const container = document.getElementById('calendarTableContainer');
      if (!records || records.length === 0) {
        container.innerHTML = '<p>No matching contracts found.</p>';
        return;
      }
      let sortedRecords = [...records];
      try {
        if (!currentSortField) {
          sortedRecords.sort((a, b) => (a.jobNumber || '').localeCompare(b.jobNumber || ''));
        } else {
          sortedRecords = sortRecords(records, currentSortField, currentSortDirection);
        }
      } catch (error) {
        debug(`Error sorting records: ${error.message}`);
        sortedRecords.sort((a, b) => (a.jobNumber || '').localeCompare(b.jobNumber || ''));
      }
      let html = '<table><thead><tr>' +
        '<th data-sort="jobNumber" onclick="sortTable(\'jobNumber\')" class="' + (currentSortField === 'jobNumber' ? 'sort-' + currentSortDirection : '') + '">Job Number</th>' +
        '<th data-sort="jobName" onclick="sortTable(\'jobName\')" class="' + (currentSortField === 'jobName' ? 'sort-' + currentSortDirection : '') + '">Job Name</th>' +
        '<th data-sort="product" onclick="sortTable(\'product\')" class="' + (currentSortField === 'product' ? 'sort-' + currentSortDirection : '') + '">Product</th>' +
        '<th data-sort="firstOnAir" onclick="sortTable(\'firstOnAir\')" class="' + (currentSortField === 'firstOnAir' ? 'sort-' + currentSortDirection : '') + '">First On Air</th>' +
        '<th data-sort="contractTerm" onclick="sortTable(\'contractTerm\')" class="' + (currentSortField === 'contractTerm' ? 'sort-' + currentSortDirection : '') + '">Contract Term</th>' +
        '<th data-sort="contractEnd" onclick="sortTable(\'contractEnd\')" class="' + (currentSortField === 'contractEnd' ? 'sort-' + currentSortDirection : '') + '">Contract Ends</th>' +
        '<th data-sort="status" onclick="sortTable(\'status\')" class="' + (currentSortField === 'status' ? 'sort-' + currentSortDirection : '') + '">Status</th>' +
        '</tr></thead><tbody>';
      sortedRecords.forEach(record => {
        const status = getJobStatus(record.firstOnAir, record.contractEnd);
        const contractTerm = formatUserFriendlyTerm(record.firstOnAir, record.contractEnd);
        html += '<tr class="' + status.class + '">' +
          '<td><a href="javascript:void(0)" onclick="showJobDetails(\'' + record.id + '\')">' + record.jobNumber + '</a></td>' +
          '<td><a href="javascript:void(0)" onclick="showJobDetails(\'' + record.id + '\')">' + record.jobName + '</a></td>' +
          '<td>' + (record.product || 'Unknown') + '</td>' +
          '<td>' + formatFriendlyDate(record.firstOnAir) + '</td>' +
          '<td>' + contractTerm + '</td>' +
          '<td>' + formatFriendlyDate(record.contractEnd) + '</td>' +
          '<td>' + status.text + '</td>' +
          '</tr>';
      });
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // Get job status based on dates
    function getJobStatus(firstOnAir, contractEnd) {
      if (!firstOnAir || !contractEnd) return { text: 'Unknown', class: '' };
      const isActive = firstOnAir <= TODAY && contractEnd >= TODAY;
      const isExpiringSoon = isActive && contractEnd <= new Date(TODAY.getTime() + 30 * 86400000);
      const isExpired = contractEnd < TODAY;
      const isUpcoming = firstOnAir > TODAY;
      if (isExpired) {
        return { text: 'Expired', class: 'expired' };
      } else if (isActive) {
        if (isExpiringSoon) {
          return { text: 'Expires Soon', class: 'expires-soon' };
        } else {
          return { text: 'Active', class: 'active' };
        }
      } else {
        return { text: 'Upcoming', class: 'upcoming' };
      }
    }

    // Render timeline view using filtered records
    function renderTimeline(records) {
      // Use default values since timeline controls were removed
      const TODAY = new Date();
      TODAY.setHours(0, 0, 0, 0);
      const timelineStart = new Date(TODAY);
      timelineStart.setMonth(TODAY.getMonth() - 6);
      timelineStart.setDate(1);
      timelineStart.setHours(0, 0, 0, 0);
      const timelineEnd = new Date(TODAY);
      timelineEnd.setMonth(TODAY.getMonth() + 18);
      timelineEnd.setDate(0);
      timelineEnd.setHours(23, 59, 59, 999);
      const MS_PER_DAY = 86400000;
      const totalDays = Math.ceil((timelineEnd - timelineStart) / MS_PER_DAY);
      const timelineWidth = totalDays * pxPerDay;
      const ruler = document.getElementById('timeline-ruler');
      const eventsDiv = document.getElementById('timeline-events');
      ruler.innerHTML = "";
      eventsDiv.innerHTML = "";
      ruler.style.width = timelineWidth + "px";
      eventsDiv.style.width = timelineWidth + "px";
      let monthPointer = new Date(timelineStart);
      while (monthPointer <= timelineEnd) {
        const daysFromStart = Math.floor((monthPointer - timelineStart) / MS_PER_DAY);
        const marker = document.createElement("div");
        marker.className = "timeline-month";
        marker.style.left = (daysFromStart * pxPerDay) + "px";
        marker.innerHTML = '<span>' + monthPointer.toLocaleString('default', { month: 'short', year: 'numeric' }) + '</span>';
        ruler.appendChild(marker);
        monthPointer.setMonth(monthPointer.getMonth() + 1);
      }
      const todayOffset = Math.floor((TODAY - timelineStart) / MS_PER_DAY) * pxPerDay;
      if (todayOffset >= 0 && todayOffset <= timelineWidth) {
        const todayMarker = document.createElement("div");
        todayMarker.className = "timeline-today";
        todayMarker.style.left = todayOffset + "px";
        eventsDiv.appendChild(todayMarker);
      }
      // Organize records into lanes to avoid overlap
      const lanes = [];
      records.sort((a, b) => a.firstOnAir - b.firstOnAir);
      records.forEach(record => {
        const { firstOnAir, contractEnd } = record;
        if (!firstOnAir || !contractEnd) return;
        if (contractEnd < timelineStart || firstOnAir > timelineEnd) return;
        let laneIndex = 0;
        let placed = false;
        while (!placed) {
          if (!lanes[laneIndex]) {
            lanes[laneIndex] = [];
            placed = true;
          } else {
            const overlaps = lanes[laneIndex].some(existingRecord => {
              return (firstOnAir <= existingRecord.contractEnd && contractEnd >= existingRecord.firstOnAir);
            });
            if (!overlaps) {
              placed = true;
            } else {
              laneIndex++;
            }
          }
          if (placed) {
            lanes[laneIndex].push(record);
          }
        }
        record.lane = laneIndex;
      });
      records.forEach(record => {
        if (record.lane === undefined) return;
        const { firstOnAir, contractEnd, lane } = record;
        if (!firstOnAir || !contractEnd) return;
        const visibleStart = firstOnAir < timelineStart ? timelineStart : firstOnAir;
        const visibleEnd = contractEnd > timelineEnd ? timelineEnd : contractEnd;
        const leftPx = Math.floor((visibleStart - timelineStart) / MS_PER_DAY) * pxPerDay;
        const widthPx = Math.max(Math.ceil((visibleEnd - visibleStart) / MS_PER_DAY) * pxPerDay, 100);
        const isActive = firstOnAir <= TODAY && contractEnd >= TODAY;
        const isExpiringSoon = isActive && contractEnd <= new Date(TODAY.getTime() + 30 * MS_PER_DAY);
        const isExpired = contractEnd < TODAY;
        const block = document.createElement("div");
        block.className = "timeline-event";
        if (isExpiringSoon) block.classList.add("timeline-event-expiring");
        if (isExpired) block.classList.add("timeline-event-expired");
        if (isActive && !isExpiringSoon) block.classList.add("timeline-event-active");
        block.style.left = leftPx + "px";
        block.style.width = widthPx + "px";
        block.style.top = (lane * 35 + 10) + "px";
        block.style.height = "24px";
        block.style.padding = "2px 4px";
        block.innerHTML = '<div class="event-title">' + record.jobName + '</div>' +
                          '<div class="event-dates">' + formatStandardDate(record.firstOnAir) + ' - ' + formatStandardDate(record.contractEnd) + '</div>';
        block.onclick = () => {
          showJobDetails(record.id);
        };
        eventsDiv.appendChild(block);
      });
      const laneCount = lanes.length;
      eventsDiv.style.height = Math.max(laneCount * 35 + 50, 200) + "px";
      const containerEl = document.getElementById('timeline-container');
      containerEl.scrollLeft = todayOffset - (containerEl.clientWidth / 2);
    }

    // Load Airtable records and render table/timeline
    async function loadCalendar() {
      const container = document.getElementById('calendarTableContainer');
      container.innerHTML = '<p>Loading contracts...</p>';
      try {
        if (currentRecords.length === 0) {
          const data = await fetchData('fetchJobs');
          if (data.error || !data.records) {
            container.innerHTML = '<p class="error">Error loading contracts: ' + (data.error || 'Unknown error') + '</p>';
            return;
          }

          // Store raw records and process them
          rawAirtableRecords = data.records;
          debug(`Received ${rawAirtableRecords.length} raw records from Airtable`);

          currentRecords = processRecords(rawAirtableRecords);
          const advertisers = extractAdvertisers();
          updateAdvertiserDropdowns(advertisers);
        }
        const filteredRecords = filterRecords(currentRecords);
        renderJobsTable(filteredRecords);
        renderTimeline(filteredRecords);
      } catch (err) {
        container.innerHTML = '<p class="error">Error loading contracts: ' + err.message + '</p>';
        debug(`Error in loadCalendar: ${err.message}`);
      }
    }

    // Load products
    async function loadProducts() {
      const container = document.getElementById('productGalleryContent');
      container.innerHTML = '<p>Loading products...</p>';
      try {
        document.getElementById('productJobsContainer').style.display = 'none';
        if (currentRecords.length > 0) {
          renderProductsFromRecords();
          return;
        }
        const data = await fetchData('fetchJobs');
        if (data.error || !data.records) {
          container.innerHTML = '<p class="error">Error loading products: ' + (data.error || 'Unknown error') + '</p>';
          return;
        }

        // Store raw records and process them
        rawAirtableRecords = data.records;
        currentRecords = processRecords(rawAirtableRecords);

        try {
          const advertisers = extractAdvertisers();
          updateAdvertiserDropdowns(advertisers);
        } catch (error) {
          debug(`Error during advertiser filter update: ${error.message}`);
        }
        renderProductsFromRecords();
      } catch (err) {
        container.innerHTML = '<p class="error">Error loading products: ' + err.message + '</p>';
        debug(`Error in loadProducts: ${err.message}`);
      }
    }

    // Render products from records (for Product Gallery)
    function renderProductsFromRecords() {
      const container = document.getElementById('productGalleryContent');
      const productFilter = document.getElementById('productFilter').value.trim().toLowerCase();
      const advertiserFilter = document.getElementById('productAdvertiserFilter').value.trim().toLowerCase();

      debug(`Rendering products with filters: ${productFilter}, ${advertiserFilter}`);

      // Group records by product
      const products = {};

      currentRecords.forEach(record => {
        // Skip records without product
        if (!record.product) return;

        const productName = record.product;

        // Apply filters
        if (productFilter && !String(productName).toLowerCase().includes(productFilter)) return;
        if (advertiserFilter && record.product.toLowerCase() !== advertiserFilter.toLowerCase()) return;

        // Create or update the product entry
        if (!products[productName]) {
          products[productName] = {
            name: productName,
            jobs: []
          };
        }

        products[productName].jobs.push(record);
      });

      const productArray = Object.values(products);
      debug(`Found ${productArray.length} unique products after filtering`);

      if (productArray.length === 0) {
        container.innerHTML = '<p>No products found matching your criteria.</p>';
        return;
      }

      let html = '';

      // Process each product into a card
      productArray.forEach(product => {
        const jobCount = product.jobs.length;
        const activeJobs = product.jobs.filter(job =>
          job.firstOnAir <= TODAY && job.contractEnd >= TODAY
        ).length;

        // Properly escape the product name for the onClick attribute
        const escapedName = String(product.name).replace(/'/g, "\\'").replace(/"/g, '\\"');

        html += `
          <div class="product-card" onclick="showProductJobs('${escapedName}')">
            <div class="card-title">${String(product.name)}</div>
            <div class="card-info">Jobs: ${jobCount} (${activeJobs} active)</div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Show jobs for a product
    function showProductJobs(productName) {
      selectedProduct = productName;
      document.getElementById('productGalleryContent').style.display = 'none';
      document.getElementById('productJobsContainer').style.display = 'block';

      // Safely set the product title
      const titleElement = document.getElementById('selectedProductTitle');
      titleElement.textContent = 'Product: ' + productName;

      debug(`Showing jobs for product: ${productName}`);

      // Get jobs for the selected product
      const productJobs = currentRecords.filter(record =>
        record.product === productName
      );

      debug(`Found ${productJobs.length} jobs for product ${productName}`);

      renderProductJobs(productJobs);
    }

    // Back to products view
    function backToProducts() {
      document.getElementById('productGalleryContent').style.display = 'grid';
      document.getElementById('productJobsContainer').style.display = 'none';
      selectedProduct = null;
    }

    // Render product jobs table with sortable columns
    function renderProductJobs(jobs) {
      const container = document.getElementById('productJobsTableContainer');
      if (!jobs || jobs.length === 0) {
        container.innerHTML = '<p>No jobs found for this product.</p>';
        return;
      }
      let sortedJobs = [...jobs];
      try {
        if (!currentSortField) {
          sortedJobs.sort((a, b) => (a.jobNumber || '').localeCompare(b.jobNumber || ''));
        } else {
          sortedJobs = sortRecords(jobs, currentSortField, currentSortDirection);
        }
      } catch (error) {
        debug(`Error sorting jobs: ${error.message}`);
        sortedJobs.sort((a, b) => (a.jobNumber || '').localeCompare(b.jobNumber || ''));
      }
      let html = '<table><thead><tr>' +
        '<th data-sort="jobNumber" onclick="sortTable(\'jobNumber\')" class="' + (currentSortField === 'jobNumber' ? 'sort-' + currentSortDirection : '') + '">Job Number</th>' +
        '<th data-sort="jobName" onclick="sortTable(\'jobName\')" class="' + (currentSortField === 'jobName' ? 'sort-' + currentSortDirection : '') + '">Job Name</th>' +
        '<th data-sort="type" onclick="sortTable(\'type\')" class="' + (currentSortField === 'type' ? 'sort-' + currentSortDirection : '') + '">Type</th>' +
        '<th data-sort="firstOnAir" onclick="sortTable(\'firstOnAir\')" class="' + (currentSortField === 'firstOnAir' ? 'sort-' + currentSortDirection : '') + '">First On Air</th>' +
        '<th data-sort="contractEnd" onclick="sortTable(\'contractEnd\')" class="' + (currentSortField === 'contractEnd' ? 'sort-' + currentSortDirection : '') + '">Contract Ends</th>' +
        '</tr></thead><tbody>';

      sortedJobs.forEach(job => {
        html += '<tr>' +
          '<td><a href="javascript:void(0)" onclick="showJobDetails(\'' + job.id + '\')">' + job.jobNumber + '</a></td>' +
          '<td><a href="javascript:void(0)" onclick="showJobDetails(\'' + job.id + '\')">' + job.jobName + '</a></td>' +
          '<td>' + (job.type || 'N/A') + '</td>' +
          '<td>' + formatFriendlyDate(job.firstOnAir) + '</td>' +
          '<td>' + formatFriendlyDate(job.contractEnd) + '</td>' +
          '</tr>';
      });

      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // Load jobs gallery
    async function loadJobsGallery() {
      const container = document.querySelector('#jobsGalleryContent .jobs-table-wrapper');
      container.innerHTML = '<p>Loading jobs...</p>';
      try {
        if (currentRecords.length > 0) {
          renderJobsGallery();
          return;
        }
        const data = await fetchData('fetchJobs');
        if (data.error || !data.records) {
          container.innerHTML = '<p class="error">Error loading jobs: ' + (data.error || 'Unknown error') + '</p>';
          return;
        }

        // Store raw records and process them
        rawAirtableRecords = data.records;
        currentRecords = processRecords(rawAirtableRecords);

        const advertisers = extractAdvertisers();
        updateAdvertiserDropdowns(advertisers);
        renderJobsGallery();
      } catch (err) {
        container.innerHTML = '<p class="error">Error loading jobs: ' + err.message + '</p>';
        debug(`Error in loadJobsGallery: ${err.message}`);
      }
    }

    // Render jobs gallery
    function renderJobsGallery() {
      const tableContainer = document.querySelector('#jobsGalleryContent .jobs-table-wrapper');
      const countDisplay = document.querySelector('#jobsGalleryContent .count-display');

      debug(`Rendering jobs gallery with ${currentRecords.length} records`);

      // Apply filters
      const jobNumberFilter = document.getElementById('jobsGalleryNumberFilter').value.trim().toLowerCase();
      const jobNameFilter = document.getElementById('jobsGalleryNameFilter').value.trim().toLowerCase();
      const advertiserFilter = document.getElementById('jobsGalleryAdvertiserFilter').value.trim().toLowerCase();

      // Start with records that have 'EG' prefix
      let filteredJobs = currentRecords.filter(job =>
        String(job.jobNumber || '').startsWith('EG')
      );

      // Apply additional user filters
      filteredJobs = filteredJobs.filter(job => {
        if (jobNumberFilter && !String(job.jobNumber || '').toLowerCase().includes(jobNumberFilter)) return false;
        if (jobNameFilter && !String(job.jobName || '').toLowerCase().includes(jobNameFilter)) return false;
        if (advertiserFilter && String(job.product || '').toLowerCase() !== advertiserFilter.toLowerCase()) return false;
        return true;
      });

      debug(`Filtered to ${filteredJobs.length} jobs`);

      // Display jobs
      if (filteredJobs.length === 0) {
        countDisplay.innerHTML = '';
        tableContainer.innerHTML = '<p>No jobs found matching your criteria.</p>';
        return;
      }

      // Update the count display
      countDisplay.innerHTML = `Displaying ${filteredJobs.length} job${filteredJobs.length !== 1 ? 's' : ''}`;

      // Create table matching the calendar view but with ability to view job details
      let html = '<table><thead><tr>' +
        '<th data-sort="jobNumber" onclick="sortTable(\'jobNumber\')" class="' + (currentSortField === 'jobNumber' ? 'sort-' + currentSortDirection : '') + '">Job Number</th>' +
        '<th data-sort="jobName" onclick="sortTable(\'jobName\')" class="' + (currentSortField === 'jobName' ? 'sort-' + currentSortDirection : '') + '">Job Name</th>' +
        '<th data-sort="product" onclick="sortTable(\'product\')" class="' + (currentSortField === 'product' ? 'sort-' + currentSortDirection : '') + '">Product</th>' +
        '<th data-sort="firstOnAir" onclick="sortTable(\'firstOnAir\')" class="' + (currentSortField === 'firstOnAir' ? 'sort-' + currentSortDirection : '') + '">First On Air</th>' +
        '<th data-sort="contractTerm" onclick="sortTable(\'contractTerm\')" class="' + (currentSortField === 'contractTerm' ? 'sort-' + currentSortDirection : '') + '">Contract Term</th>' +
        '<th data-sort="contractEnd" onclick="sortTable(\'contractEnd\')" class="' + (currentSortField === 'contractEnd' ? 'sort-' + currentSortDirection : '') + '">Contract Ends</th>' +
        '<th data-sort="status" onclick="sortTable(\'status\')" class="' + (currentSortField === 'status' ? 'sort-' + currentSortDirection : '') + '">Status</th>' +
        '<th>Actions</th>' +
        '</tr></thead><tbody>';

      filteredJobs.forEach(job => {
        const status = getJobStatus(job.firstOnAir, job.contractEnd);
        const contractTerm = formatUserFriendlyTerm(job.firstOnAir, job.contractEnd);

        html += '<tr class="' + status.class + '">' +
          '<td>' + (job.jobNumber || '') + '</td>' +
          '<td>' + (job.jobName || '') + '</td>' +
          '<td>' + (job.product || 'Unknown') + '</td>' +
          '<td>' + formatFriendlyDate(job.firstOnAir) + '</td>' +
          '<td>' + contractTerm + '</td>' +
          '<td>' + formatFriendlyDate(job.contractEnd) + '</td>' +
          '<td>' + status.text + '</td>' +
          '<td><button class="btn" onclick="showJobDetails(\'' + job.id + '\')">Details</button></td>' +
          '</tr>';
      });

      html += '</tbody></table>';
      tableContainer.innerHTML = html;

      debug("Jobs gallery rendered successfully");
    }

    // Generic fetchData function
    async function fetchData(endpoint) {
      try {
        const response = await fetch('/.netlify/functions/' + endpoint);
        const data = await response.json();
        return response.ok ? data : { error: data.error || 'Server error' };
      } catch (err) {
        return { error: err.message };
      }
    }

    // Sorting helper for table headers
    function sortTable(field) {
      if (currentSortField === field) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortField = field;
        currentSortDirection = 'asc';
      }
      // Determine active view and re-render accordingly
      const activeView = document.querySelector('.view.active');
      if (!activeView) return;
      const viewId = activeView.id;
      if (viewId === 'calendarView') {
        loadCalendar();
      } else if (viewId === 'productGallery') {
        if (document.getElementById('productJobsContainer').style.display !== 'none') {
          const productJobs = currentRecords.filter(record => record.product === selectedProduct);
          renderProductJobs(productJobs);
        } else {
          renderProductsFromRecords();
        }
      } else if (viewId === 'jobsGallery') {
        renderJobsGallery();
      }
    }

    // Tab switching logic
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        this.classList.add('active');
        const targetView = this.getAttribute('data-target');
        document.getElementById(targetView).classList.add('active');
        if (targetView === 'calendarView') {
          if (currentRecords.length === 0) loadCalendar();
        } else if (targetView === 'productGallery') {
          loadProducts();
        } else if (targetView === 'jobsGallery') {
          loadJobsGallery();
        }
      });
    });

    // Initialize on load
    window.onload = function() {
      document.getElementById('currentDate').textContent = "Today: " + formatFriendlyDate(TODAY);
      document.getElementById('zoomIn').addEventListener('click', function() {
        pxPerDay = Math.min(pxPerDay * 1.5, 50);
        renderTimeline(filterRecords(currentRecords));
      });
      document.getElementById('zoomOut').addEventListener('click', function() {
        pxPerDay = Math.max(pxPerDay / 1.5, 5);
        renderTimeline(filterRecords(currentRecords));
      });
      document.getElementById('zoomReset').addEventListener('click', function() {
        pxPerDay = 20;
        renderTimeline(filterRecords(currentRecords));
      });
      document.getElementById('centerToday').addEventListener('click', function() {
        const container = document.getElementById('timeline-container');
        const todayMarker = container.querySelector('.timeline-today');
        if (todayMarker) {
          container.scrollLeft = todayMarker.offsetLeft - (container.clientWidth / 2);
        }
      });
      const tableShowExpired = document.getElementById('tableShowExpired');
      const tableShowActive = document.getElementById('tableShowActive');
      const tableShowUpcoming = document.getElementById('tableShowUpcoming');
      if (tableShowExpired) {
        tableShowExpired.addEventListener('change', function() {
          applyTableFilters();
        });
      }
      if (tableShowActive) {
        tableShowActive.addEventListener('change', function() {
          applyTableFilters();
        });
      }
      if (tableShowUpcoming) {
        tableShowUpcoming.addEventListener('change', function() {
          applyTableFilters();
        });
      }

      // Close the modal if clicking outside
      window.addEventListener('click', function(event) {
        const modal = document.getElementById('jobDetailModal');
        if (event.target === modal) {
          modal.style.display = 'none';
        }
      });

      // Clear debug output
      const debugEl = document.getElementById('debugOutput');
      if (debugEl) {
        debugEl.innerHTML = '';
        debugEl.style.display = 'block'; // Show debug on load
      }

      loadCalendar();
    };

    // Toggle debug info
    function toggleDebug() {
      const debugEl = document.getElementById('debugOutput');
      debugEl.style.display = debugEl.style.display === 'none' ? 'block' : 'none';
    }
  </script>
</body>
</html>