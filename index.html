<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>PaloPay Client Portal Dashboard</title>
  <style>
    /* Global Styles */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f9f9f9;
    }
    header.global-header {
      text-align: center;
      margin-bottom: 10px;
      font-size: 24px;
      font-weight: bold;
    }
    header.main-header {
      text-align: center;
      margin-bottom: 20px;
    }
    /* Tabs */
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin: 0 5px;
    }
    .tab.active {
      border-color: #333;
      font-weight: bold;
    }
    .view {
      display: none;
    }
    .view.active {
      display: block;
    }
    /* Table Container (Calendar View) */
    .table-container {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 33vh;
      width: 100%;
      border: 1px solid #ccc;
      margin-top: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      min-width: 800px;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 8px;
      text-align: left;
      white-space: nowrap;
    }
    th {
      position: relative;
      cursor: pointer;
      background-color: #f2f2f2;
    }
    /* Custom sort indicator styles */
    th.sort-asc::after {
      content: " ▲";
      position: absolute;
      right: 8px;
    }
    th.sort-desc::after {
      content: " ▼";
      position: absolute;
      right: 8px;
    }
    th[data-sort] {
      cursor: pointer;
      position: relative;
    }
    th[data-sort]:hover {
      background-color: #e9e9e9;
    }
    /* Expiring date colors for table */
    tr.expires-soon td {
      background-color: #ffebee;
      color: #c62828;
    }
    tr.expired td {
      background-color: #f5f5f5;
      color: #616161;
    }
    tr.active td {
      background-color: #e3f2fd;
      color: #0d47a1;
    }
    tr.upcoming td {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    /* Gallery Card Styles */
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .campaign-card, .job-card {
      background: #fff;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
      transition: transform 0.2s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .campaign-card:hover, .job-card:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }
    .card-title {
      font-weight: bold;
      font-size: 16px;
      margin: 8px 0 4px;
    }
    .card-info {
      font-size: 12px;
      color: #666;
      margin: 2px 0;
    }
    .gallery-search {
      display: flex;
      margin-bottom: 15px;
      gap: 10px;
      flex-wrap: wrap;
    }
    .gallery-search input, .gallery-search select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .gallery-search input {
      flex: 1;
      min-width: 200px;
    }
    .btn {
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .btn:hover {
      background: #0069d9;
    }
    .btn-alt {
      background: #6c757d;
    }
    .btn-alt:hover {
      background: #5a6268;
    }
    /* Table filter controls */
    .table-controls {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      flex-wrap: wrap;
      gap: 10px;
    }
    .table-filters {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    .table-filters label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Enhanced Timeline Styles */
    .timeline-container {
      margin-bottom: 20px;
      border: 1px solid #ccc;
      padding: 10px;
      background: #fff;
      position: relative;
      overflow-x: auto;
      min-height: 300px;
    }
    .timeline-ruler {
      position: relative;
      height: 30px;
      border-bottom: 1px solid #ccc;
      z-index: 1;
    }
    .timeline-month {
      position: absolute;
      border-left: 1px solid #aaa;
      height: 15px;
      top: 15px;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
    }
    .timeline-month span {
      position: relative;
      top: -15px;
      left: 3px;
      white-space: nowrap;
      color: #333;
    }
    .timeline-events {
      position: relative;
      min-height: 200px;
      z-index: 2;
      padding-top: 10px;
    }
    /* Today marker */
    .timeline-today {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background-color: #ff4d4d;
      z-index: 5;
      box-shadow: 0 0 5px rgba(255, 0, 0, 0.3);
    }
    .timeline-today::after {
      content: "Today";
      position: absolute;
      top: -25px;
      left: -20px;
      background: #ff4d4d;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: bold;
      white-space: nowrap;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    /* Timeline event styling */
    .timeline-event {
      position: absolute;
      background: #e8f5e9;
      border: 1px solid #4caf50;
      border-radius: 4px;
      padding: 6px 8px;
      min-width: 100px;
      font-size: 12px;
      cursor: pointer;
      overflow: visible;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      z-index: 3;
    }
    .timeline-event:hover {
      transform: translateY(-2px);
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }
    .timeline-event .event-title {
      font-weight: bold;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 11px;
    }
    .timeline-event .event-dates {
      font-size: 9px;
      opacity: 0.9;
      margin-top: 2px;
    }
    .timeline-event-active {
      background: #e3f2fd;
      border-color: #2196f3;
      color: #0d47a1;
    }
    .timeline-event-expiring {
      background: #fff8e1;
      border-color: #ffc107;
      color: #ff6f00;
    }
    .timeline-event-expired {
      background: #f5f5f5;
      border-color: #9e9e9e;
      color: #616161;
      opacity: 0.85;
    }
    /* Timeline legend */
    .timeline-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 15px 0;
      border-top: 1px solid #eee;
      padding-top: 10px;
      font-size: 12px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      display: inline-block;
    }
    .color-active {
      background: #e3f2fd;
      border: 1px solid #2196f3;
    }
    .color-expiring {
      background: #fff8e1;
      border: 1px solid #ffc107;
    }
    .color-expired {
      background: #f5f5f5;
      border: 1px solid #9e9e9e;
    }
    /* Jobs Gallery styles */
    .jobs-table-wrapper {
      width: 100%;
      margin-top: 15px;
    }
    .count-display {
      margin-bottom: 15px;
    }
    /* Job detail modal */
    .job-detail-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      z-index: 1000;
    }
    .job-detail-content {
      background-color: white;
      margin: 5% auto;
      padding: 20px;
      width: 90%;
      max-width: 1200px;
      max-height: 80%;
      overflow-y: auto;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .job-detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px;
      margin-bottom: 15px;
    }
    .job-detail-close {
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
    }
    .job-detail-table {
      width: 100%;
      margin-top: 15px;
    }
    /* Debug section */
    #debugOutput {
      background-color: #f5f5f5;
      border: 1px solid #ccc;
      padding: 10px;
      margin-bottom: 10px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    /* For job detail tables */
    .job-detail-table th {
      width: 200px;
      vertical-align: top;
      background-color: #f5f5f5;
    }
    .job-detail-table td {
      vertical-align: top;
    }
  </style>
</head>
<body>
  <!-- User controls will be injected here by JS -->

  <!-- Global Header: Text instead of Logo -->
  <header class="global-header">
    DDB Melbourne
  </header>
  <!-- Main Header -->
  <header class="main-header">
    <h1>Palopay Client Portal</h1>
    <p>Dashboard – Select a view below</p>
    <div class="current-date" id="currentDate"></div>
  </header>
  <!-- Tab Navigation -->
  <div class="tabs">
    <div class="tab active" data-target="calendarView">Calendar View</div>
    <div class="tab" data-target="campaignGallery">Campaign Gallery</div>
    <div class="tab" data-target="jobsGallery">Jobs Gallery</div>
  </div>

  <!-- Calendar View -->
  <div id="calendarView" class="view active">
    <h2>Contract Expiration Calendar</h2>
    <!-- Debug Section -->
    <div id="debugOutput" class="field-debug"></div>
    <button onclick="toggleDebug()" style="margin-bottom: 10px;">Toggle Debug Info</button>
    <!-- Timeline Controls (Zoom Only) -->
    <div class="timeline-controls">
      <div>
        <button id="zoomOut">-</button>
        <button id="zoomReset">Reset Zoom</button>
        <button id="zoomIn">+</button>
        <button id="centerToday">Center on Today</button>
      </div>
    </div>
    <!-- Timeline Component -->
    <div id="timeline-container" class="timeline-container">
      <div id="timeline-ruler" class="timeline-ruler"></div>
      <div id="timeline-events" class="timeline-events"></div>
    </div>
    <h2>Contracts</h2>
    <div class="gallery-search">
      <input type="text" id="tableJobNumberFilter" placeholder="Filter by Job Number" />
      <input type="text" id="tableJobNameFilter" placeholder="Filter by Job Name" />
      <select id="advertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <button class="btn" onclick="applyTableFilters()">Search</button>
      <button class="btn btn-alt" onclick="downloadTableCSV()">Download CSV</button>
    </div>
    <!-- Table Controls -->
    <div class="table-controls">
      <div class="table-filters">
        <label><input type="checkbox" id="tableShowExpired" checked> Show Expired</label>
        <label><input type="checkbox" id="tableShowActive" checked> Show Active</label>
        <label><input type="checkbox" id="tableShowUpcoming" checked> Show Upcoming</label>
        <button class="btn" onclick="applyTableFilters()">Apply Filters</button>
      </div>
    </div>
    <div id="calendarTableContainer" class="table-container">
      Loading contracts...
    </div>
  </div>

  <!-- Campaign Gallery View -->
  <div id="campaignGallery" class="view">
    <h2>Campaign Gallery</h2>
    <div class="gallery-search">
      <input type="text" id="campaignJobNumberFilter" placeholder="Filter by Campaign Number" />
      <input type="text" id="campaignJobNameFilter" placeholder="Filter by Campaign Name" />
      <select id="campaignAdvertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <!-- Re-render campaigns with current filters -->
      <button class="btn" onclick="renderCampaignsFromRecords()">Search</button>
    </div>
    <div id="campaignGalleryContent" class="gallery-grid">
      Loading campaigns...
    </div>
    <!-- Campaign Jobs Table (hidden by default) -->
    <div id="campaignJobsContainer" style="display: none; margin-top: 20px;">
      <div class="table-header">
        <h3 id="selectedCampaignTitle">Campaign Jobs</h3>
        <button class="btn btn-alt" onclick="backToCampaigns()">Back to Campaigns</button>
        <button class="btn btn-alt" onclick="downloadCampaignJobsCSV()">Download CSV</button>
        <button class="btn btn-alt" onclick="printCampaignJobsCSV()">Print CSV</button>
      </div>

      <div id="campaignJobsTableContainer" class="table-container">
        Loading jobs...
      </div>
    </div>
  </div>

  <!-- Jobs Gallery View -->
  <div id="jobsGallery" class="view">
    <h2>Jobs Gallery</h2>
    <div class="gallery-search">
      <input type="text" id="jobsGalleryNumberFilter" placeholder="Filter by Job Number" />
      <input type="text" id="jobsGalleryNameFilter" placeholder="Filter by Job Name" />
      <select id="jobsGalleryAdvertiserFilter">
        <option value="">All Advertisers</option>
      </select>
      <button class="btn" onclick="loadJobsGallery()">Search</button>
      <button class="btn btn-alt" onclick="downloadJobsCSV()">Download CSV</button>
    </div>
    <div id="jobsGalleryContent">
      <div class="count-display"></div>
      <div class="jobs-table-wrapper table-container">
        Loading jobs...
      </div>
    </div>
  </div>

  <!-- Job Detail Modal -->
  <div id="jobDetailModal" class="job-detail-modal">
    <div class="job-detail-content">
      <div class="job-detail-header">
        <h2 id="jobDetailTitle">Job Details</h2>
        <span class="job-detail-close" onclick="closeJobDetail()">&times;</span>
      </div>
      <div id="jobDetailContent"></div>
    </div>
  </div>

  <script>
    // ---- START: ADDED AUTHENTICATION CODE ----
    // auth-check.js - Add this to index.html
    document.addEventListener('DOMContentLoaded', function() {
      checkAuth();
      setupLogoutButton(); // Make sure this is called after checkAuth creates the button
    });

    // Check if user is logged in
    function checkAuth() {
      const token = localStorage.getItem('authToken');
      const agencyName = localStorage.getItem('agencyName');

      // If no token, redirect to login page
      if (!token) {
        window.location.href = 'login.html';
        return false;
      }

      // Add user info element if it doesn't exist
      if (!document.getElementById('userInfo')) {
        const userControls = document.createElement('div');
        userControls.className = 'user-controls';
        userControls.innerHTML = `
          <div id="userInfo" class="user-info">Agency: ${agencyName || 'Unknown'}</div>
          <button id="logoutBtn" class="logout-btn">Log Out</button>
        `;

        // Add it to the top of the body
        const firstChild = document.body.firstChild;
        document.body.insertBefore(userControls, firstChild);

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
          .user-controls {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 15px; /* Adjust as needed */
            padding: 10px 20px; /* Adjust padding */
            position: absolute; /* Position relative to body */
            top: 10px; /* Adjust top position */
            right: 20px; /* Adjust right position */
            z-index: 1001; /* Ensure it's above other content */
          }
          .user-info {
            margin-right: 15px;
            font-size: 14px;
            font-weight: bold;
            color: #333; /* Adjust color if needed */
          }
          .logout-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
          }
          .logout-btn:hover {
            background: #5a6268;
          }
        `;
        document.head.appendChild(style);

        // Setup the logout button *after* it's added to the DOM
        setupLogoutButton();
      } else {
        // Update user info if it exists
        document.getElementById('userInfo').textContent = `Agency: ${agencyName || 'Unknown'}`;
      }

      return true;
    }


    // Set up logout button
    function setupLogoutButton() {
      const logoutBtn = document.getElementById('logoutBtn');
      if (logoutBtn) {
        // Remove existing listener to prevent duplicates if called multiple times
        logoutBtn.removeEventListener('click', logout);
        // Add the listener
        logoutBtn.addEventListener('click', logout);
      }
    }

    // Handle logout
    function logout() {
      // Clear authentication data
      localStorage.removeItem('authToken');
      localStorage.removeItem('agencyId');
      localStorage.removeItem('agencyName');

      // Redirect to login page
      window.location.href = 'login.html';
    }

    // Modified fetchData function with authentication
    async function fetchDataWithAuth(endpoint) {
      try {
        const token = localStorage.getItem('authToken');

        if (!token) {
          // No auth token, redirect to login
          window.location.href = 'login.html';
          return { error: 'Authentication required' };
        }

        const response = await fetch('/.netlify/functions/' + endpoint, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        const data = await response.json();

        // Check for authentication errors
        if (!response.ok) {
          if (response.status === 401) {
            // Auth error, clear token and redirect to login
            logout(); // Use the logout function to clear storage and redirect
            return { error: 'Authentication required' };
          }
          return { error: data.error || `Server error: ${response.status}` };
        }

        return data;
      } catch (err) {
        console.error("Fetch error:", err); // Log the actual error
        return { error: `Network or fetch error: ${err.message}` };
      }
    }

    // ---- END: ADDED AUTHENTICATION CODE ----


    // Global variables
    const TODAY = new Date();
    TODAY.setHours(0, 0, 0, 0);
    let pxPerDay = 20; // Default zoom level for timeline
    let currentRecords = []; // Store all records
    let currentCampaigns = []; // Store all campaigns
    let currentAdvertisers = []; // Store all advertisers for filters
    let currentSortField = 'firstOnAir'; // Default sort field
    let currentSortDirection = 'asc'; // Default sort direction
    let selectedCampaign = null; // Currently selected campaign
    let rawAirtableRecords = []; // Store the raw records from Airtable
    let personMap = {}; // Map of person record IDs to names
    let agencyMap = {}; // Map of agency record IDs to names

    // Debug helper function
    function debug(message) {
      const debugEl = document.getElementById('debugOutput');
      if (debugEl && debugEl.style.display !== 'none') { // Only log if debug is visible
          const timestamp = new Date().toLocaleTimeString();
          debugEl.innerHTML += `<div>[${timestamp}] ${message}</div>`;
          debugEl.scrollTop = debugEl.scrollHeight; // Auto-scroll
      }
      console.log(message); // Always log to console
    }

    // Extract name from a referenced record
    function extractNameFromRecord(record) {
      if (!record) return "";

      // If it's a string, just return it
      if (typeof record === 'string') return record;

      // If it's an object with fields and has a Legal Name
      if (record.fields && record.fields["Legal Name"]) {
        return record.fields["Legal Name"];
      }

      // If it's an object with a Name field
      if (record.fields && record.fields["Name"]) {
        return record.fields["Name"];
      }

      // If it's an object with a name property
      if (record.name) {
        return record.name;
      }

      // Return the ID if all else fails
      return record.id || "";
    }

    // Utility: Format date in a friendly format (e.g., 3 October 2023)
    function formatFriendlyDate(date) {
      if (!date || isNaN(date.getTime())) return "";
      return date.toLocaleDateString('en-AU', {
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      });
    }

    // Utility: Format date in standard format (DD/MM/YYYY)
    function formatStandardDate(date) {
      if (!date || isNaN(date.getTime())) return "";
      return date.toLocaleDateString('en-AU', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
      });
    }

    // Format term in user-friendly format (weeks, months, years)
    function formatUserFriendlyTerm(startDate, endDate) {
      if (!startDate || !endDate) return "N/A";
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (isNaN(start.getTime()) || isNaN(end.getTime())) return "N/A";
      const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
      if (daysDiff < 0) return "Invalid dates"; // Handle cases where end is before start
      if (daysDiff >= 365) {
          const years = Math.floor(daysDiff / 365);
          const remainingDays = daysDiff % 365;
          let term = years + (years === 1 ? ' year' : ' years');
          if (remainingDays > 0) {
              term += ` ${remainingDays} ${remainingDays === 1 ? 'day' : 'days'}`;
          }
          return term;
      }
      if (daysDiff >= 30) {
        const months = Math.floor(daysDiff / 30);
        const remainingDays = daysDiff % 30;
        let term = months + (months === 1 ? ' month' : ' months');
        if (remainingDays > 0) {
          term += ` ${remainingDays} ${remainingDays === 1 ? 'day' : 'days'}`;
        }
        return term;
      }
      if (daysDiff >= 7) {
        const weeks = Math.floor(daysDiff / 7);
        const remainingDays = daysDiff % 7;
        let term = weeks + (weeks === 1 ? ' week' : ' weeks');
         if (remainingDays > 0) {
           term += ` ${remainingDays} ${remainingDays === 1 ? 'day' : 'days'}`;
         }
        return term;
      }
      return daysDiff + (daysDiff === 1 ? ' day' : ' days');
    }

    // Improved date parser that handles multiple formats
    function parseDate(dateStr) {
        if (!dateStr) return null;
        const cleanStr = String(dateStr).trim(); // Ensure it's a string

        // Check for common invalid date strings early
        if (cleanStr === "" || cleanStr.toLowerCase() === "invalid date") return null;

        let parsedDate = null;

        // 1. ISO format: YYYY-MM-DD (potentially with time)
        // Regex allows T separator and optional time/timezone
        const isoMatch = cleanStr.match(/^(\d{4})-(\d{2})-(\d{2})(?:[ T](\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:?\d{2})?)?)?$/);
        if (isoMatch) {
            // Use Date.parse for robust ISO handling, including timezone
            const timestamp = Date.parse(cleanStr);
            if (!isNaN(timestamp)) {
                parsedDate = new Date(timestamp);
            }
        }

        // 2. DD/MM/YYYY format (common ambiguity with MM/DD/YYYY)
        // Be careful with this format; prioritize others if possible
        if (!parsedDate) {
            const dmyMatch = cleanStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
            if (dmyMatch) {
                const day = parseInt(dmyMatch[1], 10);
                const month = parseInt(dmyMatch[2], 10);
                const year = parseInt(dmyMatch[3], 10);
                // Basic validation for month/day ranges
                if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                   parsedDate = new Date(year, month - 1, day);
                   // Check if the created date matches the input day (handles invalid dates like 31/02/YYYY)
                   if (parsedDate.getDate() !== day || parsedDate.getMonth() !== month - 1 || parsedDate.getFullYear() !== year) {
                       parsedDate = null; // Invalid date created
                   }
                }
            }
        }

        // 3. "Month Day, Year" format (e.g., "January 15, 2023")
        // More robust regex for month names and optional comma
        if (!parsedDate) {
            const monthNameMatch = cleanStr.match(/^([A-Za-z]+)\s+(\d{1,2}),?\s+(\d{4})$/);
            if (monthNameMatch) {
                // Use Date constructor which handles month names well
                const timestamp = Date.parse(cleanStr);
                if (!isNaN(timestamp)) {
                    parsedDate = new Date(timestamp);
                }
            }
        }

        // 4. Fallback: Try native Date parsing (less reliable due to browser differences)
        if (!parsedDate) {
            const fallbackTimestamp = Date.parse(cleanStr);
            if (!isNaN(fallbackTimestamp)) {
                parsedDate = new Date(fallbackTimestamp);
            }
        }

        // Final check: ensure the result is a valid Date object
        if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
            // Optional: Set time to midnight UTC for consistency if needed
             parsedDate.setUTCHours(0, 0, 0, 0);
            return parsedDate;
        } else {
            console.warn("Failed to parse date:", dateStr);
            debug(`Failed to parse date string: "${dateStr}"`);
            return null;
        }
    }

    // Process Airtable records
    function processRecords(records) {
        if (!records || !Array.isArray(records)) return [];
        debug(`Processing ${records.length} records from Airtable...`);

        const processedRecords = [];
        personMap = {}; // Clear existing maps
        agencyMap = {};
        const campaignMap = {}; // Add map for campaigns
        const jobMap = {}; // Map to collect jobs by ID for linking

        // --- First Pass: Build Lookup Maps & Store Basic Record Info ---
        records.forEach(record => {
            if (!record || !record.id || !record.fields) return; // Skip invalid records
            jobMap[record.id] = record; // Store raw record by ID

            const fields = record.fields;

            // Build Person Map
            if (fields["Person"] && Array.isArray(fields["Person"])) {
                fields["Person"].forEach(personRef => {
                    if (typeof personRef === 'object' && personRef.id && personRef.fields && personRef.fields["Legal Name"]) {
                        personMap[personRef.id] = personRef.fields["Legal Name"];
                    }
                });
            }

            // Build Agency Map
            if (fields["Talent Agency"] && Array.isArray(fields["Talent Agency"])) {
                fields["Talent Agency"].forEach(agencyRef => {
                    if (typeof agencyRef === 'object' && agencyRef.id && agencyRef.fields && agencyRef.fields["Name"]) {
                        agencyMap[agencyRef.id] = agencyRef.fields["Name"];
                    }
                });
            }

            // Build Campaign Map (handle both objects and string IDs)
            if (fields["Campaign"] && Array.isArray(fields["Campaign"])) {
                fields["Campaign"].forEach(campaignRef => {
                    let campId = null;
                    let campName = null;
                    let campaignFullObject = null; // Store the full campaign object if available

                    if (typeof campaignRef === 'string') {
                        campId = campaignRef;
                    } else if (typeof campaignRef === 'object' && campaignRef.id) {
                        campId = campaignRef.id;
                        campaignFullObject = campaignRef; // Store the object
                        if (campaignRef.fields && campaignRef.fields["Name"]) {
                            campName = campaignRef.fields["Name"];
                        } else if (campaignRef.fields && campaignRef.fields["Campaign Name"]) {
                             campName = campaignRef.fields["Campaign Name"];
                        }
                    }

                    if (campId) {
                        // Store or update campaign info in the map
                        if (!campaignMap[campId]) {
                           campaignMap[campId] = { id: campId, name: campName, campaignObject: campaignFullObject };
                        } else if (campName && !campaignMap[campId].name) {
                            // Update name if we found one and it was missing
                            campaignMap[campId].name = campName;
                        }
                         if (campaignFullObject && !campaignMap[campId].campaignObject) {
                           campaignMap[campId].campaignObject = campaignFullObject; // Store object if missing
                         }
                    }
                });
            }
        });

        debug(`Built lookup maps: ${Object.keys(personMap).length} persons, ${Object.keys(agencyMap).length} agencies, ${Object.keys(campaignMap).length} campaigns`);

        // --- Second Pass: Process Each Record with Lookups ---
        records.forEach((record, index) => {
            if (!record || !record.id || !record.fields) return; // Skip invalid records

            try {
                const fields = record.fields;
                const jobId = record.id;

                // --- Basic Fields ---
                const jobNumber = fields["Job Number"] || fields["Job No."] || "";
                const jobName = fields["Job Name"] || fields["Name of Spot"] || "";

                // --- Dates (Using improved parser) ---
                const firstOnAirDate = parseDate(fields["First On Air"]);
                // Use calculated field primarily, fall back to standard, then default to 30 days after first on air
                 let contractEndDate = parseDate(fields["Contract Ends (Calculated) Date For Sorting"]) ||
                                  parseDate(fields["Contract Ends"]);

                 // If still no end date, default to 30 days after firstOnAirDate if firstOnAirDate is valid
                 if (!contractEndDate && firstOnAirDate) {
                     contractEndDate = new Date(firstOnAirDate.getTime() + 30 * 86400000);
                     debug(`Record ${jobId}: Using default 30-day end date.`);
                 }

                 // Check if dates are valid, if not, log and potentially skip or use defaults
                 if (!firstOnAirDate) {
                     debug(`Record ${jobId}: Invalid or missing 'First On Air' date. Field value: ${fields["First On Air"]}`);
                     // Decide how to handle: skip? use today? depends on requirements
                 }
                 if (!contractEndDate) {
                     debug(`Record ${jobId}: Invalid or missing 'Contract Ends' date. Field values: Calculated='${fields["Contract Ends (Calculated) Date For Sorting"]}', Standard='${fields["Contract Ends"]}'`);
                      // Decide how to handle
                 }

                // --- Product/Client ---
                const product = fields["Product"] || fields["Job Description - Product Details"] || fields["Advertiser"] || fields["Advertiser WEBSITE USE"] || "";

                // --- Campaign Info ---
                let campaignId = "";
                let campaignName = "";
                let campaignObject = null; // Store the full linked campaign object

                if (fields["Campaign"] && Array.isArray(fields["Campaign"]) && fields["Campaign"].length > 0) {
                    const campaignRef = fields["Campaign"][0];
                    let potentialId = null;
                    if (typeof campaignRef === 'string') {
                        potentialId = campaignRef;
                    } else if (typeof campaignRef === 'object' && campaignRef.id) {
                        potentialId = campaignRef.id;
                    }

                    if (potentialId && campaignMap[potentialId]) {
                        campaignId = potentialId;
                        campaignName = campaignMap[potentialId].name || ""; // Get name from map
                        campaignObject = campaignMap[potentialId].campaignObject; // Get object from map
                    }
                }
                // Fallbacks if campaign info wasn't found via linked record
                if (!campaignId && fields["Campaign ID"]) campaignId = fields["Campaign ID"];
                if (!campaignName && fields["Campaign Name"]) campaignName = fields["Campaign Name"];
                // Generate a fallback name if ID exists but name doesn't
                if (campaignId && !campaignName) campaignName = "Campaign " + campaignId.substring(0, 8); // Use partial ID for name


                // --- Person/Performer Info ---
                let performerName = "";
                let performerId = "";
                if (fields["Person"] && Array.isArray(fields["Person"]) && fields["Person"].length > 0) {
                    const personRef = fields["Person"][0];
                     if (typeof personRef === 'string') {
                         performerId = personRef;
                         performerName = personMap[performerId] || performerId; // Use map or ID
                     } else if (typeof personRef === 'object' && personRef.id) {
                         performerId = personRef.id;
                         performerName = personMap[performerId] || (personRef.fields && personRef.fields["Legal Name"]) || performerId; // Map > Field > ID
                     }
                }

                 // --- Agency Info ---
                 let agencyName = "";
                 let agencyId = "";
                 if (fields["Talent Agency"] && Array.isArray(fields["Talent Agency"]) && fields["Talent Agency"].length > 0) {
                     const agencyRef = fields["Talent Agency"][0];
                     if (typeof agencyRef === 'string') {
                         agencyId = agencyRef;
                         agencyName = agencyMap[agencyId] || agencyId; // Map or ID
                     } else if (typeof agencyRef === 'object' && agencyRef.id) {
                         agencyId = agencyRef.id;
                         agencyName = agencyMap[agencyId] || (agencyRef.fields && agencyRef.fields["Name"]) || agencyId; // Map > Field > ID
                     }
                 }

                // --- Linked Job Trackers (Retrieve raw records) ---
                const linkedJobTrackers = [];
                if (fields["Job Trackers"] && Array.isArray(fields["Job Trackers"])) {
                    fields["Job Trackers"].forEach(trackerRef => {
                        let trackerId = null;
                        if (typeof trackerRef === 'string') {
                            trackerId = trackerRef;
                        } else if (typeof trackerRef === 'object' && trackerRef.id) {
                            trackerId = trackerRef.id;
                        }
                        if (trackerId && jobMap[trackerId]) {
                            linkedJobTrackers.push(jobMap[trackerId]); // Push the raw record
                        }
                    });
                }

                // --- Other Fields ---
                const contractTerm = fields["Contract Term"] || ""; // Keep original term string if needed
                const campaignRelease = fields["Campaign Release/Usage"] || "";
                const campaignMedia = fields["Campaign Media/Deliverables"] || "";
                const territory = fields["Territory"] || fields["Shoot Location"] || "";
                const type = fields["Type"] || "";
                const headShotUrl = (fields["Head Shot"] && Array.isArray(fields["Head Shot"]) && fields["Head Shot"].length > 0) ? fields["Head Shot"][0].url : "";
                const role = fields["Role"] || "";
                const contractDORUrl = (fields["Contract / DOR"] && Array.isArray(fields["Contract / DOR"]) && fields["Contract / DOR"].length > 0) ? fields["Contract / DOR"][0].url : "";
                const jobSummary = fields["Job Summary"] || fields["Job Description - Product Details"] || "";
                const contractFee = fields["Contract Fee"] || "";
                const loading = fields["Loading"] || "";
                const options = fields["Options"] || "";
                const rollover = fields["Rollover (inc VO)"] || "";
                const voiceover = fields["Voiceover"] || "";
                const notes = fields["NOTES Job Tracker"] || "";


                // --- Create Processed Record ---
                processedRecords.push({
                    id: jobId,
                    jobNumber: jobNumber,
                    jobName: jobName,
                    product: product,
                    nameOfSpot: jobName, // Redundant? Keep for compatibility?
                    contractTerm: contractTerm, // Original term string
                    firstOnAir: firstOnAirDate, // Date object or null
                    contractEnd: contractEndDate, // Date object or null
                    campaignRelease: campaignRelease,
                    campaignMedia: campaignMedia,
                    territory: territory,
                    type: type,
                    headShot: headShotUrl, // URL or empty string
                    role: role,
                    contractDOR: contractDORUrl, // URL or empty string
                    jobSummary: jobSummary,
                    contractFee: contractFee,
                    loading: loading,
                    options: options,
                    rollover: rollover,
                    voiceover: voiceover,
                    notes: notes,
                    performerName: performerName,
                    performerId: performerId,
                    talentAgencyName: agencyName,
                    agencyId: agencyId,
                    campaignName: campaignName,
                    campaignId: campaignId,
                    campaignObject: campaignObject, // Full linked campaign object
                    linkedJobTrackers: linkedJobTrackers, // Array of raw job records
                    rawFields: fields // Keep raw fields for detailed view or debugging
                });

            } catch (error) {
                debug(`Error processing record index ${index} (ID: ${record ? record.id : 'N/A'}): ${error.message}`);
                console.error(`Error processing record index ${index}:`, error, record);
            }
        });

        debug(`Successfully processed ${processedRecords.length} out of ${records ? records.length : 0} raw records`);

        // Log some information about processed campaigns
        const uniqueCampaigns = new Set();
        processedRecords.forEach(record => {
            if (record.campaignId) {
                uniqueCampaigns.add(record.campaignId);
            } else if (record.campaignName) {
                 uniqueCampaigns.add(record.campaignName); // Add name if ID is missing
            }
        });
        debug(`Found ${uniqueCampaigns.size} unique campaign identifiers in processed records`);

        return processedRecords;
    }

    // Extract unique advertisers/products
    function extractAdvertisers() {
      const uniqueProducts = new Set();

      currentRecords.forEach(record => {
        if (record.product && typeof record.product === 'string' && record.product.trim() !== '') {
          uniqueProducts.add(record.product.trim());
        }
      });

       // Optional: Add known advertisers if they might be missing
       // const knownAdvertisers = ["Coles", "Mobil", "Dulux"];
       // knownAdvertisers.forEach(advertiser => uniqueProducts.add(advertiser));

      return Array.from(uniqueProducts).sort((a, b) => a.localeCompare(b)); // Sort alphabetically
    }

    // Populate advertiser dropdowns
    function updateAdvertiserDropdowns(advertisers) {
      const dropdownIds = ['advertiserFilter', 'campaignAdvertiserFilter', 'jobsGalleryAdvertiserFilter'];
      dropdownIds.forEach(dropdownId => {
        const dropdown = document.getElementById(dropdownId);
        if (dropdown) {
          // Preserve current selection if possible
          const currentSelection = dropdown.value;
          dropdown.innerHTML = '<option value="">All Advertisers</option>'; // Reset options
          advertisers.forEach(advertiser => {
            const option = document.createElement('option');
            option.value = advertiser;
            option.textContent = advertiser;
            // Reselect if it was the previous selection
            if (advertiser === currentSelection) {
                 option.selected = true;
            }
            dropdown.appendChild(option);
          });
        }
      });
    }

    // Updated showJobDetails function that redirects to job-details.html
    function showJobDetails(jobId) {
        debug(`Attempting to show details for job ID: ${jobId}`);
        // Find the job record by its ID from the processed records
        const job = currentRecords.find(r => r.id === jobId);

        if (!job) {
            console.error("Job details not found for ID:", jobId);
            alert("Error: Job details could not be found. The record might be missing or incomplete.");
            return;
        }

        // Prepare data to pass. Store the *entire* processed job object.
        // This gives job-details.html access to all fields, including rawFields.
        try {
            // SessionStorage has size limits, but usually fine for single objects.
            // Consider alternatives like IndexedDB if objects become extremely large.
             sessionStorage.setItem('currentJobData', JSON.stringify(job));
             debug(`Stored job data in sessionStorage for ID: ${jobId}`);

             // Redirect to the job details page, passing the job ID as a query parameter
             // This helps the target page confirm which job to load from sessionStorage.
             window.location.href = `job-details.html?jobId=${encodeURIComponent(job.id)}`;

        } catch (error) {
            console.error("Error storing job data in sessionStorage:", error);
            alert("An error occurred while preparing job details. Please try again.");
            // Optionally clear potentially corrupted sessionStorage item
            sessionStorage.removeItem('currentJobData');
        }
    }


    // Function to fetch Job Tracker records (example - likely needs actual implementation)
    async function fetchJobTrackerRecords(jobNumber) {
        debug(`Fetching job tracker records for job number: ${jobNumber}`);
        // This is a placeholder. You would typically call your Netlify function here,
        // potentially passing the job ID or number to filter in Airtable.
        // Replace with your actual API call using fetchDataWithAuth.
        try {
             // Example assuming your function expects a job number
             const data = await fetchDataWithAuth('fetchJobTrackers?jobNumber=' + encodeURIComponent(jobNumber));
             if (data.error) {
                throw new Error(data.error);
             }
             debug(`Successfully fetched ${data.records ? data.records.length : 0} job tracker records.`);
             return data.records || [];
        } catch (error) {
            console.error('Error fetching job tracker records:', error);
            debug(`Error fetching job tracker records: ${error.message}`);
            alert(`Could not fetch related job records: ${error.message}`);
            return []; // Return empty array on error
        }
    }


    // Show jobs for a selected campaign
    function showCampaignJobs(campaignId, campaignName) {
        selectedCampaign = campaignId; // Store the selected campaign ID
        document.getElementById('campaignGalleryContent').style.display = 'none'; // Hide gallery
        document.getElementById('campaignJobsContainer').style.display = 'block'; // Show jobs table container

        // Safely set the campaign title, handling potential special characters
        const titleElement = document.getElementById('selectedCampaignTitle');
        titleElement.textContent = 'Jobs for Campaign: ' + (campaignName || `ID ${campaignId}`); // Display name or ID

        debug(`Showing jobs for campaign: ID=${campaignId}, Name=${campaignName}`);

        // Filter jobs belonging to the selected campaign
        const campaignJobs = currentRecords.filter(record => {
            // Primary check: Match campaignId directly
             if (record.campaignId === campaignId) return true;

             // Secondary check: Check if the campaignId exists in the raw linked Campaign field
             if (record.rawFields && record.rawFields["Campaign"] && Array.isArray(record.rawFields["Campaign"])) {
                 return record.rawFields["Campaign"].some(ref => {
                     if (typeof ref === 'string') return ref === campaignId;
                     if (typeof ref === 'object' && ref.id) return ref.id === campaignId;
                     return false;
                 });
             }
             // Tertiary check (less reliable): Match campaign name if ID match failed
             if (!record.campaignId && record.campaignName && record.campaignName === campaignName) return true;


            return false;
        });

        debug(`Found ${campaignJobs.length} jobs for campaign ${campaignId}`);

        // Render the table with the filtered jobs
        renderCampaignJobs(campaignJobs);
    }


    // Close job detail modal (if used - currently redirects)
    function closeJobDetail() {
      document.getElementById('jobDetailModal').style.display = 'none';
    }

    // Download table data as CSV
    function downloadGenericCSV(containerId, filename) {
        debug(`Attempting to download CSV for container: ${containerId}, filename: ${filename}`);
        try {
            const table = document.querySelector(`#${containerId} table`);
            if (!table) {
                console.error(`Table not found within container #${containerId}`);
                alert(`Could not find the table to export for ${filename}.`);
                return;
            }

            const headers = [];
            // Get headers from thead cells, handling potential complex content
            table.querySelectorAll('thead th').forEach(th => {
                // Prioritize data-sort attribute if available, otherwise use textContent
                 const headerText = th.dataset.sort ? th.dataset.sort : th.textContent.trim();
                 // Escape double quotes within the header itself
                 headers.push(`"${headerText.replace(/"/g, '""')}"`);
            });

             if (headers.length === 0) {
                 console.error("No headers found in the table.");
                 alert("Cannot export table with no headers.");
                 return;
             }

            const rows = [];
            // Get data from tbody rows and cells
            table.querySelectorAll('tbody tr').forEach(row => {
                const rowData = [];
                row.querySelectorAll('td').forEach(td => {
                    // Get text content, trim whitespace
                    let cellContent = td.textContent.trim();
                    // Escape double quotes by doubling them, enclose in double quotes
                    rowData.push(`"${cellContent.replace(/"/g, '""')}"`);
                });
                 // Ensure the number of columns matches the headers
                 if (rowData.length === headers.length) {
                    rows.push(rowData.join(','));
                 } else {
                    console.warn("Skipping row with mismatched column count:", rowData);
                 }
            });

            const csvContent = [
                headers.join(','), // Header row
                ...rows             // Data rows
            ].join('\n'); // Join rows with newline characters

            // Create a Blob and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);

            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click(); // Simulate click to trigger download
            document.body.removeChild(link); // Clean up the link element
            URL.revokeObjectURL(url); // Release the object URL

            debug(`CSV download initiated for ${filename}`);

        } catch (err) {
            console.error(`Error downloading CSV for ${containerId}:`, err);
            alert(`Could not download CSV (${filename}). An error occurred. Please check the console.`);
            debug(`CSV download failed for ${filename}: ${err.message}`);
        }
    }


    // Specific CSV download wrappers
    function downloadTableCSV() {
      downloadGenericCSV('calendarTableContainer', 'contracts_calendar_view.csv');
    }
    function downloadCampaignJobsCSV() {
      // Use a dynamic filename based on the selected campaign
       const campaignName = document.getElementById('selectedCampaignTitle')?.textContent.replace('Campaign: ', '') || selectedCampaign || 'selected_campaign';
       const safeFilename = campaignName.replace(/[^a-z0-9]/gi, '_').toLowerCase(); // Sanitize filename
      downloadGenericCSV('campaignJobsTableContainer', `campaign_${safeFilename}_jobs.csv`);
    }
    function downloadJobsCSV() {
      downloadGenericCSV('jobsGalleryContent .jobs-table-wrapper', 'all_jobs_gallery.csv'); // Target the specific wrapper
    }

    // Print CSV function (Opens CSV content in a new window for printing)
    function printCampaignJobsCSV() {
        debug("Attempting to print campaign jobs CSV");
        try {
             const table = document.querySelector("#campaignJobsTableContainer table");
             if (!table) {
                 alert("No table found to print CSV data.");
                 return;
             }

             const headers = [];
             table.querySelectorAll('thead th').forEach(th => {
                 const headerText = th.dataset.sort ? th.dataset.sort : th.textContent.trim();
                 headers.push(`"${headerText.replace(/"/g, '""')}"`);
             });

             const rows = [];
             table.querySelectorAll('tbody tr').forEach(row => {
                 const rowData = [];
                 row.querySelectorAll('td').forEach(td => {
                     let cellContent = td.textContent.trim();
                     rowData.push(`"${cellContent.replace(/"/g, '""')}"`);
                 });
                  if (rowData.length === headers.length) {
                     rows.push(rowData.join(','));
                  }
             });

             const csvContent = [headers.join(','), ...rows].join('\n');

             // Open a new window and write the CSV content inside <pre> tags for formatting
             const printWindow = window.open("", "_blank");
             if (!printWindow) {
                 alert("Could not open print window. Please check your browser's popup blocker settings.");
                 return;
             }
             printWindow.document.write("<html><head><title>Print Campaign Jobs</title></head><body><pre>");
             printWindow.document.write(csvContent.replace(/</g, "&lt;").replace(/>/g, "&gt;")); // Basic escaping for HTML
             printWindow.document.write("</pre></body></html>");
             printWindow.document.close(); // Necessary for some browsers
             printWindow.focus(); // Bring window to front

             // Delay print slightly to ensure content is rendered
             setTimeout(() => {
                try {
                    printWindow.print();
                   // Optional: Close window after print dialog is handled (can be unreliable)
                   // printWindow.close();
                } catch (printError) {
                    console.error("Error initiating print:", printError);
                    alert("Could not initiate print automatically. Please use the browser's print function (Ctrl/Cmd+P) in the new window.");
                }
            }, 500); // 500ms delay

            debug("Print window opened with CSV data.");

        } catch (err) {
            console.error("Error preparing CSV for printing:", err);
            alert("An error occurred while preparing the data for printing.");
            debug(`CSV print preparation failed: ${err.message}`);
        }
    }

    // Sort records based on field and direction
    function sortRecords(records, field, direction) {
        if (!records || !Array.isArray(records)) return [];
        if (!field) return records; // No field to sort by

        return [...records].sort((a, b) => { // Use spread to avoid modifying original array
            let valA = a[field];
            let valB = b[field];

            // Handle Date objects
            if (valA instanceof Date && valB instanceof Date) {
                 // Treat null/invalid dates as earliest or latest depending on direction
                const timeA = !isNaN(valA.getTime()) ? valA.getTime() : (direction === 'asc' ? Infinity : -Infinity);
                const timeB = !isNaN(valB.getTime()) ? valB.getTime() : (direction === 'asc' ? Infinity : -Infinity);
                return direction === 'asc' ? timeA - timeB : timeB - timeA;
            }

            // Handle Numbers (e.g., contractFee could be numeric)
            if (typeof valA === 'number' && typeof valB === 'number') {
               return direction === 'asc' ? valA - valB : valB - valA;
            }

            // Handle Strings (case-insensitive comparison)
            // Convert null/undefined to empty strings for comparison
            valA = String(valA || '').toLowerCase();
            valB = String(valB || '').toLowerCase();

            if (valA < valB) return direction === 'asc' ? -1 : 1;
            if (valA > valB) return direction === 'asc' ? 1 : -1;
            return 0; // Values are equal
        });
    }


    // Filter records based on active filters for a specific view
    function filterRecords(records, filterSet = 'table') {
        if (!records || !Array.isArray(records)) return [];
        debug(`Filtering ${records.length} records for '${filterSet}' view`);

        try {
            // --- Get Filter Input Elements ---
            const numberInputId = filterSet === 'table' ? 'tableJobNumberFilter' :
                                  filterSet === 'campaign' ? 'campaignJobNumberFilter' :
                                  'jobsGalleryNumberFilter';
            const nameInputId = filterSet === 'table' ? 'tableJobNameFilter' :
                                filterSet === 'campaign' ? 'campaignJobNameFilter' :
                                'jobsGalleryNameFilter';
            const advertiserSelectId = filterSet === 'table' ? 'advertiserFilter' :
                                     filterSet === 'campaign' ? 'campaignAdvertiserFilter' :
                                     'jobsGalleryAdvertiserFilter';

            const numberElement = document.getElementById(numberInputId);
            const nameElement = document.getElementById(nameInputId);
            const advertiserElement = document.getElementById(advertiserSelectId);

            // --- Get Filter Values ---
            const numberValue = numberElement ? numberElement.value.trim().toLowerCase() : '';
            const nameValue = nameElement ? nameElement.value.trim().toLowerCase() : '';
            const advertiserValue = advertiserElement ? advertiserElement.value.trim().toLowerCase() : ''; // Lowercase for comparison

            // --- Get Status Filter Values (only for 'table' view) ---
            let showExpired = true, showActive = true, showUpcoming = true;
            if (filterSet === 'table') {
                const expiredCheckbox = document.getElementById('tableShowExpired');
                const activeCheckbox = document.getElementById('tableShowActive');
                const upcomingCheckbox = document.getElementById('tableShowUpcoming');
                showExpired = expiredCheckbox ? expiredCheckbox.checked : true;
                showActive = activeCheckbox ? activeCheckbox.checked : true;
                showUpcoming = upcomingCheckbox ? upcomingCheckbox.checked : true;
            }

            // --- Apply Filters ---
            const filtered = records.filter(record => {
                // Filter by Job Number (if value provided)
                if (numberValue && !String(record.jobNumber || '').toLowerCase().includes(numberValue)) {
                    return false;
                }

                // Filter by Job Name (if value provided)
                if (nameValue && !String(record.jobName || '').toLowerCase().includes(nameValue)) {
                    return false;
                }

                // Filter by Advertiser/Product (if value provided)
                if (advertiserValue && String(record.product || '').toLowerCase() !== advertiserValue) {
                     return false;
                 }

                // Filter by Status (only for 'table' view)
                if (filterSet === 'table') {
                    // Determine the status based on valid dates
                    let status = 'unknown';
                    if (record.firstOnAir instanceof Date && record.contractEnd instanceof Date &&
                        !isNaN(record.firstOnAir.getTime()) && !isNaN(record.contractEnd.getTime())) {

                        const start = record.firstOnAir;
                        const end = record.contractEnd;

                         if (end < TODAY) {
                             status = 'expired';
                         } else if (start > TODAY) {
                             status = 'upcoming';
                         } else { // start <= TODAY && end >= TODAY
                             status = 'active';
                         }
                    }

                    // Apply status checkboxes
                    if (status === 'expired' && !showExpired) return false;
                    if (status === 'active' && !showActive) return false;
                    if (status === 'upcoming' && !showUpcoming) return false;
                }

                // If all checks passed, include the record
                return true;
            });

            debug(`Filtering complete. ${filtered.length} records passed for '${filterSet}' view.`);
            return filtered;

        } catch (error) {
            debug(`Error during filtering for '${filterSet}': ${error.message}`);
            console.error(`Error in filterRecords for ${filterSet}:`, error);
            return records; // Return original records on error to avoid breaking UI
        }
    }

    // Apply filters and re-render the active view (Calendar: Table + Timeline)
    function applyTableFilters() {
        debug("Applying table filters...");
        const filtered = filterRecords(currentRecords, 'table'); // Use 'table' filter set
        renderJobsTable(filtered);   // Re-render the main contracts table
        renderTimeline(filtered);    // Re-render the timeline with the same filtered data
        debug("Table filters applied and views updated.");
    }


    // Render the main contracts table (Calendar View)
    function renderJobsTable(recordsToRender) {
        const container = document.getElementById('calendarTableContainer');
        if (!container) return; // Exit if container doesn't exist

        debug(`Rendering jobs table with ${recordsToRender ? recordsToRender.length : 0} records.`);

        if (!recordsToRender || recordsToRender.length === 0) {
            container.innerHTML = '<p>No matching contracts found based on current filters.</p>';
            return;
        }

        // Sort the records based on current sort settings
        let sortedRecords;
        try {
            sortedRecords = sortRecords(recordsToRender, currentSortField, currentSortDirection);
        } catch (error) {
            debug(`Error sorting records for table: ${error.message}`);
            console.error("Sorting error:", error);
            sortedRecords = recordsToRender; // Use unsorted on error
        }

        // Build table header with sort indicators
        const headers = [
            { field: 'jobNumber', label: 'Job Number' },
            { field: 'jobName', label: 'Job Name' },
            { field: 'product', label: 'Product' },
            { field: 'firstOnAir', label: 'First On Air' },
             // Use a custom field name for the calculated term for sorting if needed
            { field: 'calculatedTerm', label: 'Contract Term' }, // Display name
            { field: 'contractEnd', label: 'Contract Ends' },
            { field: 'status', label: 'Status' } // Use a generic status field for sorting
        ];

        let headerHtml = '<table><thead><tr>';
        headers.forEach(header => {
            const sortClass = (currentSortField === header.field) ? `sort-${currentSortDirection}` : '';
            // Use data-sort attribute for the actual field name used in sorting
            headerHtml += `<th data-sort="${header.field}" onclick="sortTable('${header.field}')" class="${sortClass}">${header.label}</th>`;
        });
        headerHtml += '</tr></thead><tbody>';

        // Build table body
        let bodyHtml = '';
        sortedRecords.forEach(record => {
            const statusInfo = getJobStatus(record.firstOnAir, record.contractEnd);
            // Calculate user-friendly term *for display* here
            const displayTerm = formatUserFriendlyTerm(record.firstOnAir, record.contractEnd);
            // Ensure dates are valid before formatting
            const firstOnAirFormatted = formatFriendlyDate(record.firstOnAir);
            const contractEndFormatted = formatFriendlyDate(record.contractEnd);

            // Add data-id attribute for potential future use (e.g., highlighting)
            bodyHtml += `<tr class="${statusInfo.class}" data-id="${record.id}">
                <td><a href="#" onclick="event.preventDefault(); showJobDetails('${record.id}')">${record.jobNumber || ''}</a></td>
                <td><a href="#" onclick="event.preventDefault(); showJobDetails('${record.id}')">${record.jobName || ''}</a></td>
                <td>${record.product || 'N/A'}</td>
                <td>${firstOnAirFormatted || 'N/A'}</td>
                <td>${displayTerm || 'N/A'}</td>
                <td>${contractEndFormatted || 'N/A'}</td>
                <td>${statusInfo.text || 'Unknown'}</td>
            </tr>`;
        });
        bodyHtml += '</tbody></table>';

        // Update the container
        container.innerHTML = headerHtml + bodyHtml;
        debug("Jobs table rendering complete.");
    }

    // Get job status (text and CSS class) based on dates
    function getJobStatus(firstOnAir, contractEnd) {
        // Ensure dates are valid Date objects
        if (!(firstOnAir instanceof Date) || isNaN(firstOnAir.getTime()) ||
            !(contractEnd instanceof Date) || isNaN(contractEnd.getTime())) {
            return { text: 'Invalid Dates', class: 'status-unknown' };
        }

         // Ensure TODAY is also a valid date (should be set globally)
         if (!(TODAY instanceof Date) || isNaN(TODAY.getTime())) {
             console.error("TODAY constant is not a valid date!");
             return { text: 'Error', class: 'status-error' };
         }


        const thirtyDaysFromNow = new Date(TODAY.getTime() + 30 * 86400000); // 30 days in milliseconds

        // Compare date objects directly
        if (contractEnd < TODAY) {
            return { text: 'Expired', class: 'expired' }; // Clearly expired
        } else if (firstOnAir > TODAY) {
            return { text: 'Upcoming', class: 'upcoming' }; // Starts in the future
        } else { // Contract is currently active (firstOnAir <= TODAY && contractEnd >= TODAY)
            if (contractEnd <= thirtyDaysFromNow) {
                return { text: 'Expires Soon', class: 'expires-soon' }; // Active but ending within 30 days
            } else {
                return { text: 'Active', class: 'active' }; // Active and not expiring soon
            }
        }
    }

    // Render the timeline view
    function renderTimeline(recordsToRender) {
        debug(`Rendering timeline with ${recordsToRender ? recordsToRender.length : 0} records. Zoom: ${pxPerDay}px/day.`);
        const timelineContainer = document.getElementById('timeline-container');
        const ruler = document.getElementById('timeline-ruler');
        const eventsDiv = document.getElementById('timeline-events');
        if (!timelineContainer || !ruler || !eventsDiv) return;

        // --- Timeline Setup ---
        const MS_PER_DAY = 86400000;
        // Define timeline range (e.g., 6 months before today to 18 months after)
        const timelineStart = new Date(TODAY);
        timelineStart.setMonth(TODAY.getMonth() - 6);
        timelineStart.setDate(1); // Start at the beginning of the month
        timelineStart.setHours(0, 0, 0, 0);

        const timelineEnd = new Date(TODAY);
        timelineEnd.setMonth(TODAY.getMonth() + 18);
        timelineEnd.setDate(0); // End at the end of the month (day 0 of next month)
        timelineEnd.setHours(23, 59, 59, 999);

        const totalDays = Math.ceil((timelineEnd - timelineStart) / MS_PER_DAY);
        const timelineWidth = totalDays * pxPerDay;

        // Clear previous contents and set dimensions
        ruler.innerHTML = "";
        eventsDiv.innerHTML = "";
        ruler.style.width = `${timelineWidth}px`;
        eventsDiv.style.width = `${timelineWidth}px`;

        // --- Render Ruler (Months) ---
        let monthPointer = new Date(timelineStart);
        while (monthPointer <= timelineEnd) {
            const daysFromStart = Math.floor((monthPointer - timelineStart) / MS_PER_DAY);
            const marker = document.createElement("div");
            marker.className = "timeline-month";
            marker.style.left = `${daysFromStart * pxPerDay}px`;
             // Format: MMM YYYY (e.g., Jan 2024)
             marker.innerHTML = `<span>${monthPointer.toLocaleString('default', { month: 'short' })} ${monthPointer.getFullYear()}</span>`;
            ruler.appendChild(marker);
            // Move to the first day of the next month
            monthPointer.setMonth(monthPointer.getMonth() + 1);
            monthPointer.setDate(1);
        }

        // --- Render Today Marker ---
        const todayOffsetDays = Math.floor((TODAY - timelineStart) / MS_PER_DAY);
        const todayOffsetPx = todayOffsetDays * pxPerDay;
        if (todayOffsetPx >= 0 && todayOffsetPx <= timelineWidth) {
            const todayMarker = document.createElement("div");
            todayMarker.className = "timeline-today";
            todayMarker.style.left = `${todayOffsetPx}px`;
            eventsDiv.appendChild(todayMarker);
        } else {
            debug("Today marker is outside the current timeline range.");
        }

        // --- Prepare Records for Lane Allocation ---
         // Filter out records with invalid dates before processing
         const validRecords = recordsToRender.filter(record =>
             record.firstOnAir instanceof Date && !isNaN(record.firstOnAir.getTime()) &&
             record.contractEnd instanceof Date && !isNaN(record.contractEnd.getTime()) &&
             record.contractEnd >= record.firstOnAir // Basic sanity check
         );
        // Sort by start date to optimize lane finding
        validRecords.sort((a, b) => a.firstOnAir - b.firstOnAir);

        // --- Lane Allocation (Simple greedy approach) ---
        const lanes = []; // Each element will be the 'end pixel' of the last event in that lane
        const laneHeight = 35; // Total height per lane (event + gap)
        const eventHeight = 24; // Actual event bar height

         validRecords.forEach(record => {
             const startPx = Math.floor((record.firstOnAir - timelineStart) / MS_PER_DAY) * pxPerDay;
             const endPx = Math.ceil((record.contractEnd - timelineStart) / MS_PER_DAY) * pxPerDay; // Use ceil for end

              // Find the first available lane
              let assignedLane = -1;
              for (let i = 0; i < lanes.length; i++) {
                 // Check if the new event starts after the last event in this lane ends (with a small gap)
                 if (startPx >= (lanes[i] + 5)) { // 5px gap
                     lanes[i] = endPx; // Update lane end pixel
                     assignedLane = i;
                     break;
                 }
              }

              // If no suitable lane found, create a new one
              if (assignedLane === -1) {
                 lanes.push(endPx);
                 assignedLane = lanes.length - 1;
              }
             record.lane = assignedLane; // Store lane index on the record
         });


        // --- Render Events ---
        validRecords.forEach(record => {
            if (record.lane === undefined) return; // Skip if not assigned a lane

            // Calculate pixel positions and width, clamped to timeline boundaries
            const startDay = Math.max(0, Math.floor((record.firstOnAir - timelineStart) / MS_PER_DAY));
            const endDay = Math.min(totalDays, Math.ceil((record.contractEnd - timelineStart) / MS_PER_DAY));

            const leftPx = startDay * pxPerDay;
            // Ensure minimum width for visibility, but don't exceed timeline width
            const widthPx = Math.max(pxPerDay, (endDay - startDay) * pxPerDay); // Min width of 1 day's px value

            // Determine status class
             const statusInfo = getJobStatus(record.firstOnAir, record.contractEnd);
             let eventClass = `timeline-event timeline-event-${statusInfo.class.replace('expires-soon', 'expiring').replace('status-', '')}`; // Normalize class names


            // Create the event block
            const block = document.createElement("div");
            block.className = eventClass;
            block.style.left = `${leftPx}px`;
            block.style.width = `${widthPx}px`;
            block.style.top = `${record.lane * laneHeight + 10}px`; // Position based on lane + top padding
            block.style.height = `${eventHeight}px`;
            block.title = `${record.jobName}\n${formatStandardDate(record.firstOnAir)} - ${formatStandardDate(record.contractEnd)}`; // Tooltip

            // Add content (optional, can be done with pseudo-elements or kept minimal)
             // block.innerHTML = `<span class="event-label-timeline">${record.jobName}</span>`; // Example label

            // Add click handler to show details
            block.onclick = () => {
                showJobDetails(record.id);
            };

            eventsDiv.appendChild(block);
        });

        // Adjust the height of the events container based on the number of lanes used
        const requiredHeight = lanes.length * laneHeight + 40; // Add padding
        eventsDiv.style.minHeight = `${Math.max(200, requiredHeight)}px`; // Ensure minimum height

         // --- Center on Today (optional, can be done via button) ---
         const centerOnLoad = true; // Set to false if you prefer manual centering
         if (centerOnLoad && todayOffsetPx >= 0 && todayOffsetPx <= timelineWidth) {
             setTimeout(() => { // Use timeout to ensure layout is complete
                 timelineContainer.scrollLeft = todayOffsetPx - (timelineContainer.clientWidth / 2);
                 debug("Timeline centered on 'Today'.");
             }, 100);
         }
        debug("Timeline rendering complete.");
    }


    // Add custom CSS styles for timeline (called once on load)
    function addCustomTimelineStyles() {
      const styleId = 'custom-timeline-styles';
      if (document.getElementById(styleId)) return; // Prevent adding multiple times

      const styleElement = document.createElement('style');
      styleElement.id = styleId;
      styleElement.textContent = `
        /* Base Timeline Event Block */
        .timeline-event {
            position: absolute;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
            box-sizing: border-box;
            overflow: hidden; /* Hide overflow for clean bars */
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .timeline-event:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 15; /* Bring to front on hover */
        }

        /* Color Coding based on Status */
        .timeline-event-active {
            background-color: #a0d2eb; /* Light blue */
            border: 1px solid #4a90e2; /* Darker blue border */
        }
        .timeline-event-expiring {
            background-color: #fce8b2; /* Light yellow */
            border: 1px solid #f5a623; /* Orange border */
        }
        .timeline-event-expired {
            background-color: #e0e0e0; /* Light grey */
            border: 1px solid #9e9e9e; /* Darker grey border */
            opacity: 0.8;
        }
         .timeline-event-upcoming {
             background-color: #c8e6c9; /* Light green */
             border: 1px solid #4caf50; /* Darker green border */
         }
         .timeline-event-unknown, .timeline-event-invalid {
             background-color: #fce4ec; /* Light pink/red */
             border: 1px solid #e91e63; /* Red border */
             opacity: 0.7;
         }

        /* Optional: Inner Label (if needed) */
        .event-label-timeline {
             font-size: 10px;
             color: #333;
             padding: 0 4px;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             line-height: 22px; /* Match event height */
             display: block;
        }
         .timeline-event-expired .event-label-timeline {
             color: #757575;
             text-decoration: line-through;
         }

         /* Ensure ruler text is visible */
         .timeline-month span {
            position: relative;
            top: -16px; /* Adjust vertical position */
            left: 3px;
            white-space: nowrap;
            color: #333;
            font-size: 11px; /* Slightly smaller */
            font-weight: normal; /* Less bold */
            background: rgba(255, 255, 255, 0.7); /* Semi-transparent background */
            padding: 0 2px;
            border-radius: 2px;
         }
         .timeline-month {
             border-left: 1px dotted #ccc; /* Dotted line for month marker */
             height: 100%; /* Extend line down */
             top: 0;
         }
         /* Today Marker Styling */
        .timeline-today {
            position: absolute;
            top: 0;
            bottom: 0; /* Extend full height */
            width: 2px;
            background-color: #ff4d4d; /* Bright red */
            z-index: 10; /* Above events */
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.4);
            pointer-events: none; /* Allow clicks through */
        }
        .timeline-today::after {
            content: "Today";
            position: absolute;
            top: -20px; /* Position above ruler */
            left: -18px; /* Center the label */
            background: #ff4d4d;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
      `;
      document.head.appendChild(styleElement);
       debug("Custom timeline styles added.");
    }

    // Load Calendar View data (initial load or refresh)
    async function loadCalendar() {
        const container = document.getElementById('calendarTableContainer');
        if (!container) return;
        container.innerHTML = '<p>Loading contracts...</p>'; // Show loading state
        debug("Loading calendar data...");

        try {
            // Fetch data only if currentRecords is empty (initial load)
            if (currentRecords.length === 0) {
                debug("Fetching initial records from server...");
                 const data = await fetchDataWithAuth('fetchJobs'); // Use authenticated fetch

                 if (data.error || !data.records) {
                     const errorMsg = data.error || 'No records returned from server.';
                     console.error('Error loading contracts:', errorMsg);
                     container.innerHTML = `<p class="error">Error loading contracts: ${errorMsg}</p>`;
                     debug(`Error loading contracts: ${errorMsg}`);
                     return;
                 }

                 // Store raw records and process them
                 rawAirtableRecords = data.records;
                 debug(`Received ${rawAirtableRecords.length} raw records from Airtable.`);

                 currentRecords = processRecords(rawAirtableRecords);

                // Extract and update advertiser dropdowns after processing
                try {
                    const advertisers = extractAdvertisers();
                    updateAdvertiserDropdowns(advertisers);
                    debug(`Updated advertiser dropdowns with ${advertisers.length} advertisers.`);
                } catch (dropdownError) {
                   debug(`Error updating advertiser dropdowns: ${dropdownError.message}`);
                   console.error("Dropdown update error:", dropdownError);
                }
            } else {
                debug("Using cached records for calendar view.");
            }

            // Apply current filters (including status checkboxes) and render
            applyTableFilters(); // This now calls filterRecords, renderJobsTable, and renderTimeline

            // Optional: Add timeline legend (can be complex, example below)
            // renderTimelineLegend();

        } catch (err) {
            container.innerHTML = `<p class="error">Error loading contracts: ${err.message}</p>`;
            console.error('Error in loadCalendar:', err);
            debug(`Fatal error in loadCalendar: ${err.message}`);
        }
    }

    // Add styles for timeline text (if needed - might be handled by custom styles now)
    function addTimelineTextStyles() {
        // This function might be redundant if addCustomTimelineStyles handles everything.
        // If specific text styling is needed beyond the main event block, add it here.
        // Example:
        // const styleId = 'timeline-text-styles';
        // if (document.getElementById(styleId)) return;
        // const styleElement = document.createElement('style');
        // styleElement.id = styleId;
        // styleElement.textContent = ` ... specific text styles ... `;
        // document.head.appendChild(styleElement);
        // debug("Timeline text styles added.");
    }


    // Load Campaign Gallery data
    async function loadCampaigns() {
        const container = document.getElementById('campaignGalleryContent');
        if (!container) return;
        container.innerHTML = '<p>Loading campaigns...</p>';
        document.getElementById('campaignJobsContainer').style.display = 'none'; // Hide jobs table initially
        debug("Loading campaign gallery data...");

        try {
            // Fetch data only if currentRecords is empty
            if (currentRecords.length === 0) {
                 debug("Fetching initial records for campaigns...");
                 const data = await fetchDataWithAuth('fetchJobs'); // Authenticated fetch

                 if (data.error || !data.records) {
                     const errorMsg = data.error || 'No records returned.';
                     console.error('Error loading campaign data:', errorMsg);
                     container.innerHTML = `<p class="error">Error loading campaigns: ${errorMsg}</p>`;
                     debug(`Error loading campaign data: ${errorMsg}`);
                     return;
                 }

                 rawAirtableRecords = data.records;
                 debug(`Received ${rawAirtableRecords.length} raw records.`);
                 currentRecords = processRecords(rawAirtableRecords);

                 // Update advertiser dropdowns
                 try {
                     const advertisers = extractAdvertisers();
                     updateAdvertiserDropdowns(advertisers);
                     debug(`Updated campaign advertiser dropdowns with ${advertisers.length} advertisers.`);
                 } catch (dropdownError) {
                     debug(`Error updating campaign dropdowns: ${dropdownError.message}`);
                     console.error("Campaign dropdown error:", dropdownError);
                 }
            } else {
                 debug("Using cached records for campaign gallery.");
            }

            // Render campaign cards using the (potentially filtered) records
            renderCampaignsFromRecords();

        } catch (err) {
            container.innerHTML = `<p class="error">Error loading campaigns: ${err.message}</p>`;
            console.error('Error in loadCampaigns:', err);
            debug(`Fatal error in loadCampaigns: ${err.message}`);
        }
    }

    // Add advanced timeline styles (likely redundant if covered by addCustomTimelineStyles)
    function addAdvancedTimelineStyles() {
        // Check if these styles are truly distinct from addCustomTimelineStyles.
        // If not, consolidate into one function.
        // debug("Adding advanced timeline styles (potentially redundant).");
    }

    // Render campaign cards in the Campaign Gallery view
    function renderCampaignsFromRecords() {
        const container = document.getElementById('campaignGalleryContent');
        if (!container) return;

        // Get filter values from campaign gallery controls
        const campaignNumberFilter = document.getElementById('campaignJobNumberFilter')?.value.trim().toLowerCase() || '';
        const campaignNameFilter = document.getElementById('campaignJobNameFilter')?.value.trim().toLowerCase() || '';
        const advertiserFilter = document.getElementById('campaignAdvertiserFilter')?.value.trim().toLowerCase() || '';

        debug(`Rendering campaign gallery with filters: Number='${campaignNumberFilter}', Name='${campaignNameFilter}', Advertiser='${advertiserFilter}'`);

        // --- Group Records by Campaign ---
        const campaigns = {}; // Use an object for efficient grouping by ID

        currentRecords.forEach(record => {
            // Determine the primary campaign identifier (ID preferred, then Name, then Product)
            let campaignId = record.campaignId || null;
            let campaignName = record.campaignName || null;
            const product = record.product || 'Unknown Product'; // Use a default if missing

            // If no ID, try to use Name as a key (less reliable)
            const campaignKey = campaignId || campaignName || product; // Use ID > Name > Product as the key

            if (!campaignKey) return; // Skip if no identifier

             // --- Apply Filters ---
             // Check campaign ID/Number (if filter applied)
             if (campaignNumberFilter && !String(record.jobNumber || '').toLowerCase().includes(campaignNumberFilter) && !String(campaignId || '').toLowerCase().includes(campaignNumberFilter)) {
                 // If filtering by number, check both job number and campaign ID/key
                 // Let's refine: filter should apply to the campaign identifier or maybe job numbers within?
                 // Current logic: if campaignNumberFilter is set, the *campaign key* must contain it.
                 if (!String(campaignKey).toLowerCase().includes(campaignNumberFilter)) return;
             }
             // Check campaign name (if filter applied)
             if (campaignNameFilter && !String(campaignName || campaignKey).toLowerCase().includes(campaignNameFilter)) {
                 return;
             }
             // Check advertiser/product (if filter applied)
             if (advertiserFilter && String(product).toLowerCase() !== advertiserFilter) {
                 return;
             }


            // Create or update the campaign entry in the campaigns object
            if (!campaigns[campaignKey]) {
                campaigns[campaignKey] = {
                    id: campaignId, // May be null if grouped by name/product
                    key: campaignKey, // The identifier used for grouping
                    name: campaignName || campaignKey, // Best available name
                    jobs: [],
                    product: product,
                    // Store first valid start/end dates found for potential display
                    firstStartDate: record.firstOnAir,
                    lastEndDate: record.contractEnd
                };
            } else {
                 // Update start/end dates if applicable
                 if (record.firstOnAir && (!campaigns[campaignKey].firstStartDate || record.firstOnAir < campaigns[campaignKey].firstStartDate)) {
                     campaigns[campaignKey].firstStartDate = record.firstOnAir;
                 }
                 if (record.contractEnd && (!campaigns[campaignKey].lastEndDate || record.contractEnd > campaigns[campaignKey].lastEndDate)) {
                     campaigns[campaignKey].lastEndDate = record.contractEnd;
                 }
                 // Update name if a better one is found (e.g., linked record name)
                 if (campaignName && campaigns[campaignKey].name === campaigns[campaignKey].key) {
                    campaigns[campaignKey].name = campaignName;
                 }
            }

            campaigns[campaignKey].jobs.push(record); // Add the job record to this campaign
        });

        const campaignArray = Object.values(campaigns);
        debug(`Found ${campaignArray.length} unique campaigns matching criteria.`);

        if (campaignArray.length === 0) {
            container.innerHTML = '<p>No campaigns found matching your criteria.</p>';
            return;
        }

        // Sort campaigns (e.g., alphabetically by name)
        campaignArray.sort((a, b) => String(a.name).localeCompare(String(b.name)));

        // --- Generate HTML for Campaign Cards ---
        let html = '';
        campaignArray.forEach(campaign => {
            const jobCount = campaign.jobs.length;
            // Count active jobs within this campaign
            const activeJobs = campaign.jobs.filter(job => {
                 const status = getJobStatus(job.firstOnAir, job.contractEnd);
                 return status.class === 'active' || status.class === 'expires-soon';
            }).length;

            // Escape campaign name and ID for use in JavaScript function call
            // Use campaign.key as the identifier passed to showCampaignJobs
            const escapedKey = String(campaign.key).replace(/'/g, "\\'").replace(/"/g, '\\"');
            const escapedName = String(campaign.name).replace(/'/g, "\\'").replace(/"/g, '\\"');


            html += `
                <div class="campaign-card" onclick="showCampaignJobs('${escapedKey}', '${escapedName}')" title="Click to see jobs for ${campaign.name}">
                    <div class="card-title">${campaign.name}</div>
                    <div class="card-info">Client: ${campaign.product}</div>
                    <div class="card-info">Total Jobs: ${jobCount}</div>
                    <div class="card-info">Active/Expiring Jobs: ${activeJobs}</div>
                     ${campaign.firstStartDate ? `<div class="card-info">Dates: ${formatStandardDate(campaign.firstStartDate)} - ${formatStandardDate(campaign.lastEndDate)}</div>` : ''}
                </div>
            `;
        });

        container.innerHTML = html; // Update the gallery content
        debug("Campaign gallery rendering complete.");
    }


    // Back to campaigns view from jobs list
    function backToCampaigns() {
      document.getElementById('campaignGalleryContent').style.display = 'grid'; // Show gallery grid
      document.getElementById('campaignJobsContainer').style.display = 'none'; // Hide jobs table
      selectedCampaign = null; // Clear selected campaign ID
      debug("Returned to campaign gallery view.");
    }

    // Render the table of jobs for a specific campaign
    function renderCampaignJobs(jobs) {
        const container = document.getElementById('campaignJobsTableContainer');
        if (!container) return;

        debug(`Rendering campaign jobs table with ${jobs ? jobs.length : 0} jobs.`);

        if (!jobs || jobs.length === 0) {
            container.innerHTML = '<p>No jobs found for this campaign.</p>';
            return;
        }

        // Sort the jobs based on current sort settings
        let sortedJobs;
        try {
            // Default sort for this view if none selected? e.g., by Job Number
             const defaultSortField = 'jobNumber';
             sortedJobs = sortRecords(jobs, currentSortField || defaultSortField, currentSortDirection);
        } catch (error) {
            debug(`Error sorting campaign jobs: ${error.message}`);
            console.error("Sorting error:", error);
            sortedJobs = jobs; // Use unsorted on error
        }

        // Define headers for the campaign jobs table
        const headers = [
            { field: 'jobNumber', label: 'Job Number' },
            { field: 'jobName', label: 'Job Name' },
            { field: 'performerName', label: 'Performer' },
            { field: 'talentAgencyName', label: 'Agency' },
            { field: 'product', label: 'Product' }, // Already available
            { field: 'type', label: 'Type' },
            { field: 'firstOnAir', label: 'First On Air' },
            { field: 'contractEnd', label: 'Contract Ends' },
            { field: 'status', label: 'Status' } // Add status column
        ];

        let headerHtml = '<table><thead><tr>';
        headers.forEach(header => {
            const sortClass = (currentSortField === header.field) ? `sort-${currentSortDirection}` : '';
            headerHtml += `<th data-sort="${header.field}" onclick="sortTable('${header.field}')" class="${sortClass}">${header.label}</th>`;
        });
        headerHtml += '</tr></thead><tbody>';

        // Build table body
        let bodyHtml = '';
        sortedJobs.forEach(job => {
            const statusInfo = getJobStatus(job.firstOnAir, job.contractEnd);
            const firstOnAirFormatted = formatFriendlyDate(job.firstOnAir);
            const contractEndFormatted = formatFriendlyDate(job.contractEnd);

             // Use link to trigger job details view
            bodyHtml += `<tr class="${statusInfo.class}" data-id="${job.id}">
                <td><a href="#" onclick="event.preventDefault(); showJobDetails('${job.id}')">${job.jobNumber || ''}</a></td>
                <td><a href="#" onclick="event.preventDefault(); showJobDetails('${job.id}')">${job.jobName || ''}</a></td>
                <td>${job.performerName || 'N/A'}</td>
                <td>${job.talentAgencyName || 'N/A'}</td>
                <td>${job.product || 'N/A'}</td>
                <td>${job.type || 'N/A'}</td>
                <td>${firstOnAirFormatted || 'N/A'}</td>
                <td>${contractEndFormatted || 'N/A'}</td>
                <td>${statusInfo.text || 'Unknown'}</td>
            </tr>`;
        });
        bodyHtml += '</tbody></table>';

        // Update the container
        container.innerHTML = headerHtml + bodyHtml;
        debug("Campaign jobs table rendering complete.");
    }


    // Load Jobs Gallery view data
    async function loadJobsGallery() {
        const containerWrapper = document.querySelector('#jobsGalleryContent .jobs-table-wrapper');
        if (!containerWrapper) return;
        containerWrapper.innerHTML = '<p>Loading jobs...</p>'; // Loading state
         document.querySelector('#jobsGalleryContent .count-display').innerHTML = ''; // Clear count
        debug("Loading jobs gallery data...");

        try {
            // Fetch data only if currentRecords is empty
            if (currentRecords.length === 0) {
                debug("Fetching initial records for jobs gallery...");
                const data = await fetchDataWithAuth('fetchJobs'); // Authenticated fetch

                if (data.error || !data.records) {
                     const errorMsg = data.error || 'No records returned.';
                     console.error('Error loading jobs gallery data:', errorMsg);
                     containerWrapper.innerHTML = `<p class="error">Error loading jobs: ${errorMsg}</p>`;
                     debug(`Error loading jobs gallery data: ${errorMsg}`);
                     return;
                 }

                 rawAirtableRecords = data.records;
                 debug(`Received ${rawAirtableRecords.length} raw records.`);
                 currentRecords = processRecords(rawAirtableRecords);

                 // Update advertiser dropdowns
                 try {
                     const advertisers = extractAdvertisers();
                     updateAdvertiserDropdowns(advertisers);
                     debug(`Updated jobs gallery advertiser dropdowns with ${advertisers.length} advertisers.`);
                 } catch (dropdownError) {
                     debug(`Error updating jobs gallery dropdowns: ${dropdownError.message}`);
                     console.error("Jobs gallery dropdown error:", dropdownError);
                 }
            } else {
                debug("Using cached records for jobs gallery.");
            }

            // Render the jobs gallery table using filtered data
            renderJobsGallery();

        } catch (err) {
            containerWrapper.innerHTML = `<p class="error">Error loading jobs: ${err.message}</p>`;
            console.error('Error in loadJobsGallery:', err);
            debug(`Fatal error in loadJobsGallery: ${err.message}`);
        }
    }

    // Render the Jobs Gallery table (similar to Calendar View table but maybe different columns/actions)
    function renderJobsGallery() {
        const tableContainer = document.querySelector('#jobsGalleryContent .jobs-table-wrapper');
        const countDisplay = document.querySelector('#jobsGalleryContent .count-display');
        if (!tableContainer || !countDisplay) return;

        debug("Rendering jobs gallery table...");

        // Apply filters specific to the Jobs Gallery view
        const filteredJobs = filterRecords(currentRecords, 'jobsGallery'); // Use 'jobsGallery' filter set

        debug(`Filtered to ${filteredJobs.length} jobs for gallery view.`);

        // Update the count display
        countDisplay.textContent = `Displaying ${filteredJobs.length} job${filteredJobs.length !== 1 ? 's' : ''}`;

        if (filteredJobs.length === 0) {
            tableContainer.innerHTML = '<p>No jobs found matching your criteria.</p>';
            return;
        }

        // Sort the filtered jobs
        let sortedJobs;
        try {
             // Default sort for jobs gallery? e.g., by Job Number or Name
             const defaultSortField = 'jobNumber';
             sortedJobs = sortRecords(filteredJobs, currentSortField || defaultSortField, currentSortDirection);
        } catch (error) {
            debug(`Error sorting jobs gallery: ${error.message}`);
            console.error("Sorting error:", error);
            sortedJobs = filteredJobs; // Use unsorted on error
        }

        // Define headers for the Jobs Gallery table
        const headers = [
            { field: 'jobNumber', label: 'Job Number' },
            { field: 'jobName', label: 'Job Name' },
            { field: 'product', label: 'Product' },
            { field: 'firstOnAir', label: 'First On Air' },
            { field: 'calculatedTerm', label: 'Contract Term' }, // Display name
            { field: 'contractEnd', label: 'Contract Ends' },
            { field: 'status', label: 'Status' },
             // Add an 'Actions' column for the details button
             { field: 'actions', label: 'Actions', noSort: true } // Indicate no sorting for this column
        ];

        let headerHtml = '<table><thead><tr>';
        headers.forEach(header => {
            if (header.noSort) {
                 headerHtml += `<th>${header.label}</th>`;
            } else {
                const sortClass = (currentSortField === header.field) ? `sort-${currentSortDirection}` : '';
                headerHtml += `<th data-sort="${header.field}" onclick="sortTable('${header.field}')" class="${sortClass}">${header.label}</th>`;
            }
        });
        headerHtml += '</tr></thead><tbody>';


        // Build table body
        let bodyHtml = '';
        sortedJobs.forEach(job => {
            const statusInfo = getJobStatus(job.firstOnAir, job.contractEnd);
            const displayTerm = formatUserFriendlyTerm(job.firstOnAir, job.contractEnd);
            const firstOnAirFormatted = formatFriendlyDate(job.firstOnAir);
            const contractEndFormatted = formatFriendlyDate(job.contractEnd);

            bodyHtml += `<tr class="${statusInfo.class}" data-id="${job.id}">
                <td>${job.jobNumber || ''}</td>
                <td>${job.jobName || ''}</td>
                <td>${job.product || 'N/A'}</td>
                <td>${firstOnAirFormatted || 'N/A'}</td>
                <td>${displayTerm || 'N/A'}</td>
                <td>${contractEndFormatted || 'N/A'}</td>
                <td>${statusInfo.text || 'Unknown'}</td>
                <td><button class="btn btn-alt" style="padding: 3px 8px; font-size: 12px;" onclick="showJobDetails('${job.id}')">Details</button></td>
            </tr>`;
        });
        bodyHtml += '</tbody></table>';

        // Update the container
        tableContainer.innerHTML = headerHtml + bodyHtml;
        debug("Jobs gallery table rendering complete.");
    }

    // --- REMOVED original fetchData function ---
    // async function fetchData(endpoint) { ... }

    // Sorting handler for table headers
    function sortTable(field) {
      debug(`Sorting by field: ${field}`);
      if (currentSortField === field) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
        debug(` -> Toggled direction to: ${currentSortDirection}`);
      } else {
        currentSortField = field;
        currentSortDirection = 'asc';
        debug(` -> Set new field, direction: ${currentSortDirection}`);
      }

      // Determine active view and re-render the appropriate table/list
      const activeView = document.querySelector('.view.active');
      if (!activeView) {
          debug("Error: Could not find active view for sorting.");
          return;
      }

      const viewId = activeView.id;
      debug(` -> Re-rendering sorted view: ${viewId}`);

      switch (viewId) {
          case 'calendarView':
              // Re-filter and re-render the main contracts table
              renderJobsTable(filterRecords(currentRecords, 'table'));
              // Timeline doesn't usually need re-sorting, but might need re-filtering if filters changed
              // renderTimeline(filterRecords(currentRecords, 'table')); // Usually filtering is enough
              break;
          case 'campaignGallery':
              // Check if the campaign jobs table is visible
              if (document.getElementById('campaignJobsContainer').style.display !== 'none' && selectedCampaign) {
                 // Re-filter and render the jobs for the selected campaign
                 const campaignJobs = currentRecords.filter(record => {
                    // Use the same logic as showCampaignJobs to find relevant jobs
                     if (record.campaignId === selectedCampaign) return true;
                     if (record.rawFields && record.rawFields["Campaign"] && Array.isArray(record.rawFields["Campaign"])) {
                        return record.rawFields["Campaign"].some(ref => (typeof ref === 'string' && ref === selectedCampaign) || (typeof ref === 'object' && ref.id === selectedCampaign));
                     }
                     return false; // Add more fallback logic if needed
                  });
                 renderCampaignJobs(campaignJobs); // Render the sorted job list
              } else {
                 // If viewing campaign cards, sorting doesn't apply directly here,
                 // but re-rendering might re-apply card sorting if implemented
                 renderCampaignsFromRecords();
              }
              break;
          case 'jobsGallery':
              // Re-filter and re-render the jobs gallery table
              renderJobsGallery();
              break;
          default:
              debug(`Warning: Unknown view ID ('${viewId}') encountered during sorting.`);
      }
       debug("Sorting applied and view updated.");
    }

    // Tab switching logic
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const targetViewId = this.getAttribute('data-target');
        debug(`Switching tab to: ${targetViewId}`);

        // Deactivate current tab/view
        document.querySelector('.tab.active')?.classList.remove('active');
        document.querySelector('.view.active')?.classList.remove('active');

        // Activate new tab/view
        this.classList.add('active');
        const targetView = document.getElementById(targetViewId);
        if (targetView) {
            targetView.classList.add('active');
        } else {
            debug(`Error: Target view '${targetViewId}' not found.`);
            return; // Stop if view doesn't exist
        }


        // Load data for the activated view if needed (or just re-render if data exists)
        switch (targetViewId) {
            case 'calendarView':
                 // Always reload or re-render calendar/timeline as filters might apply
                 loadCalendar(); // This function handles fetching if necessary
                 break;
            case 'campaignGallery':
                 loadCampaigns(); // Handles fetching if necessary
                 break;
            case 'jobsGallery':
                 loadJobsGallery(); // Handles fetching if necessary
                 break;
            default:
                 debug(`No specific load action defined for view: ${targetViewId}`);
        }
         // Reset sort state when switching tabs? Optional.
         // currentSortField = 'defaultSortField'; // e.g., 'firstOnAir' or 'jobNumber'
         // currentSortDirection = 'asc';
      });
    });

    // Initialize on page load
    window.onload = function() {
        debug("Window loaded. Initializing dashboard...");
        // Ensure auth check runs (it should via DOMContentLoaded, but belt-and-suspenders)
         if (!checkAuth()) {
             debug("Auth check failed on load, redirecting...");
             return; // Stop initialization if not authenticated
         }

        // Display today's date
        const currentDateEl = document.getElementById('currentDate');
        if (currentDateEl) {
            currentDateEl.textContent = "Today: " + formatFriendlyDate(TODAY);
        }

        // --- Event Listeners for Controls ---

        // Timeline Zoom/Center (Calendar View)
        const zoomInBtn = document.getElementById('zoomIn');
        const zoomOutBtn = document.getElementById('zoomOut');
        const zoomResetBtn = document.getElementById('zoomReset');
        const centerTodayBtn = document.getElementById('centerToday');

        if (zoomInBtn) zoomInBtn.addEventListener('click', () => {
            pxPerDay = Math.min(pxPerDay * 1.5, 60); // Max zoom increased
             debug(`Zoom In: pxPerDay = ${pxPerDay}`);
            renderTimeline(filterRecords(currentRecords, 'table'));
        });
        if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => {
             pxPerDay = Math.max(pxPerDay / 1.5, 3); // Min zoom decreased
             debug(`Zoom Out: pxPerDay = ${pxPerDay}`);
             renderTimeline(filterRecords(currentRecords, 'table'));
        });
        if (zoomResetBtn) zoomResetBtn.addEventListener('click', () => {
             pxPerDay = 20; // Reset to default
             debug(`Zoom Reset: pxPerDay = ${pxPerDay}`);
             renderTimeline(filterRecords(currentRecords, 'table'));
        });
        if (centerTodayBtn) centerTodayBtn.addEventListener('click', () => {
             debug("Centering timeline on Today...");
             const container = document.getElementById('timeline-container');
             const todayMarker = container?.querySelector('.timeline-today');
             if (container && todayMarker) {
                 container.scrollLeft = todayMarker.offsetLeft - (container.clientWidth / 2);
                 debug(" -> Centered.");
             } else {
                 debug(" -> Could not find timeline container or today marker.");
             }
        });

        // Status Filter Checkboxes (Calendar View)
        const tableShowExpired = document.getElementById('tableShowExpired');
        const tableShowActive = document.getElementById('tableShowActive');
        const tableShowUpcoming = document.getElementById('tableShowUpcoming');

        if (tableShowExpired) tableShowExpired.addEventListener('change', applyTableFilters);
        if (tableShowActive) tableShowActive.addEventListener('change', applyTableFilters);
        if (tableShowUpcoming) tableShowUpcoming.addEventListener('change', applyTableFilters);

        // --- Initial Styling Functions ---
        addCustomTimelineStyles(); // Add base timeline styles
        // addTimelineTextStyles(); // Add if needed
        // addAdvancedTimelineStyles(); // Add if needed and distinct


        // --- Modal Click-Outside Close ---
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('jobDetailModal');
            // Close only if modal exists, is visible, and the click target is the modal background itself
            if (modal && modal.style.display !== 'none' && event.target === modal) {
                closeJobDetail();
            }
        });

        // --- Debug Output Setup ---
        const debugEl = document.getElementById('debugOutput');
        if (debugEl) {
            debugEl.innerHTML = 'Debug Initialized...\n'; // Clear previous content
            // Set initial state based on preference (e.g., hidden by default)
            debugEl.style.display = 'none'; // Start hidden
            debug("Debug output initialized.");
        } else {
            console.warn("Debug output element not found.");
        }

        // --- Initial Data Load ---
        // Load the default view (Calendar View)
        loadCalendar();

        debug("Initialization complete.");
    }; // End window.onload

    // Toggle debug info visibility
    function toggleDebug() {
        const debugEl = document.getElementById('debugOutput');
        if (debugEl) {
            const isHidden = debugEl.style.display === 'none';
            debugEl.style.display = isHidden ? 'block' : 'none';
            debug(`Debug output toggled ${isHidden ? 'ON' : 'OFF'}.`);
            if (isHidden) {
                 debugEl.scrollTop = debugEl.scrollHeight; // Scroll to bottom when shown
            }
        }
    }

  </script>
</body>
</html>